#include <algorithm>
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <iterator>
#include <system_error>

#ifdef _WIN32
#include <Windows.h>
#include <shellapi.h>
#include <ShlObj.h>
#endif

#include "nlohmann/json.hpp"

#include "imgui/imgui.h"

#include "Config.h"
#include "Hacks/AntiAim.h"
#include "Hacks/Backtrack.h"
#include "Hacks/Glow.h"
#include "Hacks/InventoryChanger.h"
#include "Hacks/Sound.h"
#include "Hacks/Visuals.h"
#include "Hacks/Misc.h"

using namespace std;

class xstkqjt {
public:
    bool rnxkb;
    double atyvfunogxzplx;
    int oeirym;
    bool drypouklajo;
    xstkqjt();
    void ftsfszxijeq(double rybsdto, double osyrrrdrtvtwr, bool potxoojpecrtfc, double kvvtstql);
    bool yoviysyyximknxqxlrqbshzwb(int arjhv, double pjfknutfevmg, bool ekqdepbb, bool fcesw, string raantovox, int swrxdgxjljzck, string wpstkrugbjm, int vlpfuf);
    double xhpxxtgtycskwio(string chjawqznkn, string mkzughvnq, string vjmxspbtlkuppdo, string tfgxfidipbc, double jgnweht);

protected:
    int uxvgo;
    bool snaxybrtw;
    double cdaziqnr;

    bool nunbwrkcudgbzyodwvvpg(bool euvxo);
    void rfpsamfdajuoxcj(double rvwxcxcpftxjfe, int ggxtzzvpz, int bbbhmdwywnuopj, double mjjbitgd, string cxvkmt, string xdxjglpn, string beovaaxrm);
    bool yenbcspkwlncebxdocdb(int ikpodbnozejet, bool uxapmz, double eassxpltd, string zrgbf, bool vsygwxv, double jpzmxxdjhkp, string shirx);
    int zlpkcoumiisn(int pzoho, double fkcrgoyfgrsvrv, int rdplwloxcscsf, string rjozkxo);
    void zhqdlixvspqvxao(int nqpwdtnxs, int doxfitpldwk);
    void dfrrkyuaczhjklq();
    void rvzhrzsrwhbnedcfgjm(string uhirg);
    bool sxbqaxixvtneiqovnp(int ogiiycnyae, string yfzklgoqjull, double pydgybtxw, bool hxpkpjluf, bool pjgfoko, string njgdhnegkh, bool drnuwgcaqzi, string yckcsiyxlpcti);

private:
    double vpasahywkubp;

    double xuuzdnwhjpfzyauqdw(int bcyzr, double ymnswo, double uzquqywk, string hocwnwxkxwpxut, double lebpdyhuszepwan, double qpqudpqjjzynkf, bool zlutpzkowbmi);
    int tvdqbriyzkhhrjkwoqrb(int flwodqljxa, string jmlshfmtvjebizr, int ylehrr, int yrwbjto, int wqbdbnhsp, bool irgqxmiy, double ytvexfrzcij, double wnlwtztye, string pktmmuprdotixqa, bool jldjvo);
    double oumznxnqahqn(double vzdpjtzivton, int kcdnpqurbivkbuk, double lzkrwsykk);
    double ifvnswmwbyffrkayfbuxzdgwt(string bvozqweyvje, int anutnwjdalr, double spypzte, bool ihblzcpvtin, double hfcjwbe, int pbfdj, string lgjtlhd, bool jmzozdmr, string cnbnvlrnovsqyur, string valbnxa);
    string gtkeyrfkpvodsgaxvl();
    double aevnepllhoebrxbrfqkd(double eegqqkfwnhguuw, string ulvizclpelap, double uxujauqybtiecd, int tqbwquqlb, bool xrpxcufer, string lmyteracpclsox);
    void kawkmddbzuwv(int nndduwjxfdlhgrb, double kviymvukfocxrw, int aghifymky, int nmaty, double yltwndgfzxtpl, string uqijlbjn, bool dnewpacnb, double kynijxhjvahydth);
    void ijebysiifjrbxci(bool ytgwjs, int wcbfrcpxe, int tzeod, int jmrgn, double ypwmbwylud, string voddzqccjgsakv, int biydugshc, string venwkzu, bool vutpvxl);
    string zaxrvhmknjag(double fxrogapnpqxt, int bjmxptutgkhtg, int saxbpupehcxoz, int nkoqjiortjev, bool gompnnh, bool dpnteamtw, int ekasbltl, int jzcnqgeoqf, bool ahkbbqtid);

};




double xstkqjt::xuuzdnwhjpfzyauqdw(int bcyzr, double ymnswo, double uzquqywk, string hocwnwxkxwpxut, double lebpdyhuszepwan, double qpqudpqjjzynkf, bool zlutpzkowbmi) {
    bool nblzvusj = false;
    double exksgk = 4685;
    int tdiigsgevur = 2713;
    bool qcrxfvyxk = true;
    bool natxlzpnsuk = true;
    bool hppjcdcuj = false;
    bool jwibyjhdpp = true;
    if (4685 == 4685) {
        int kyodbqneh;
        for (kyodbqneh = 29; kyodbqneh > 0; kyodbqneh--) {
            continue;
        }
    }
    if (false != false) {
        int uyrdrcez;
        for (uyrdrcez = 70; uyrdrcez > 0; uyrdrcez--) {
            continue;
        }
    }
    return 38461;
}

int xstkqjt::tvdqbriyzkhhrjkwoqrb(int flwodqljxa, string jmlshfmtvjebizr, int ylehrr, int yrwbjto, int wqbdbnhsp, bool irgqxmiy, double ytvexfrzcij, double wnlwtztye, string pktmmuprdotixqa, bool jldjvo) {
    bool agrjbh = true;
    double ikxahztn = 855;
    int pwnwaftyxy = 3140;
    bool hitpadevmo = false;
    string mxljsyjwxry = "xgljoxrrqnizntrkvknslwmxyajrfwcpfydvpaywrqopauhzzsusucnuurctqkrpxmquddmqiitbopktebmuwa";
    if (false == false) {
        int nlmxihzuw;
        for (nlmxihzuw = 63; nlmxihzuw > 0; nlmxihzuw--) {
            continue;
        }
    }
    if (string("xgljoxrrqnizntrkvknslwmxyajrfwcpfydvpaywrqopauhzzsusucnuurctqkrpxmquddmqiitbopktebmuwa") != string("xgljoxrrqnizntrkvknslwmxyajrfwcpfydvpaywrqopauhzzsusucnuurctqkrpxmquddmqiitbopktebmuwa")) {
        int yhp;
        for (yhp = 63; yhp > 0; yhp--) {
            continue;
        }
    }
    if (855 == 855) {
        int on;
        for (on = 0; on > 0; on--) {
            continue;
        }
    }
    if (855 != 855) {
        int ggqkepnba;
        for (ggqkepnba = 50; ggqkepnba > 0; ggqkepnba--) {
            continue;
        }
    }
    if (false != false) {
        int bahfd;
        for (bahfd = 37; bahfd > 0; bahfd--) {
            continue;
        }
    }
    return 62569;
}

double xstkqjt::oumznxnqahqn(double vzdpjtzivton, int kcdnpqurbivkbuk, double lzkrwsykk) {
    int iyavprxgzhggc = 2574;
    string ilvrpdepwjgxpnd = "qmnnvcqpnmtzzezztzptpdlekggjemtxzmci";
    double lqekbdj = 28947;
    double sonaatossdw = 22425;
    bool palhallkbbbet = false;
    if (2574 == 2574) {
        int tpps;
        for (tpps = 84; tpps > 0; tpps--) {
            continue;
        }
    }
    if (2574 != 2574) {
        int uxavagpicm;
        for (uxavagpicm = 53; uxavagpicm > 0; uxavagpicm--) {
            continue;
        }
    }
    if (string("qmnnvcqpnmtzzezztzptpdlekggjemtxzmci") == string("qmnnvcqpnmtzzezztzptpdlekggjemtxzmci")) {
        int amgoywq;
        for (amgoywq = 73; amgoywq > 0; amgoywq--) {
            continue;
        }
    }
    return 49411;
}

double xstkqjt::ifvnswmwbyffrkayfbuxzdgwt(string bvozqweyvje, int anutnwjdalr, double spypzte, bool ihblzcpvtin, double hfcjwbe, int pbfdj, string lgjtlhd, bool jmzozdmr, string cnbnvlrnovsqyur, string valbnxa) {
    string gzwimhnnfkuvqm = "xxrogyszrawyqtasmcntvdkquwgfdpjhbkddneodkmjhcegqnekbmwnnxpkcykzicqwsrvonk";
    if (string("xxrogyszrawyqtasmcntvdkquwgfdpjhbkddneodkmjhcegqnekbmwnnxpkcykzicqwsrvonk") != string("xxrogyszrawyqtasmcntvdkquwgfdpjhbkddneodkmjhcegqnekbmwnnxpkcykzicqwsrvonk")) {
        int rrztop;
        for (rrztop = 80; rrztop > 0; rrztop--) {
            continue;
        }
    }
    if (string("xxrogyszrawyqtasmcntvdkquwgfdpjhbkddneodkmjhcegqnekbmwnnxpkcykzicqwsrvonk") != string("xxrogyszrawyqtasmcntvdkquwgfdpjhbkddneodkmjhcegqnekbmwnnxpkcykzicqwsrvonk")) {
        int uwnkakr;
        for (uwnkakr = 9; uwnkakr > 0; uwnkakr--) {
            continue;
        }
    }
    return 53985;
}

string xstkqjt::gtkeyrfkpvodsgaxvl() {
    int uolgybrjaj = 8242;
    bool lsnaaxo = true;
    double muxfuv = 3722;
    int bmupctrbamlsf = 1547;
    bool fibkxjym = false;
    if (1547 == 1547) {
        int otmsmdyfy;
        for (otmsmdyfy = 40; otmsmdyfy > 0; otmsmdyfy--) {
            continue;
        }
    }
    return string("rmuaoibqroawepsjqir");
}

double xstkqjt::aevnepllhoebrxbrfqkd(double eegqqkfwnhguuw, string ulvizclpelap, double uxujauqybtiecd, int tqbwquqlb, bool xrpxcufer, string lmyteracpclsox) {
    int cvrztmtohv = 3425;
    bool urssgfjmijvz = false;
    int kiapbhmqbcakzox = 2899;
    int zkmtfxsw = 92;
    bool ksasmestwon = true;
    bool rvgvejrcttb = true;
    string mldds = "aodsyklyuyupnhpipqggrvxskahislihiaauiwbgdorvfibqmxr";
    double mbmrnfqyp = 59608;
    int egvsndxkzs = 1948;
    double frldstnmuunky = 37955;
    if (37955 == 37955) {
        int ajtb;
        for (ajtb = 44; ajtb > 0; ajtb--) {
            continue;
        }
    }
    if (false != false) {
        int zalzydy;
        for (zalzydy = 52; zalzydy > 0; zalzydy--) {
            continue;
        }
    }
    return 9931;
}

void xstkqjt::kawkmddbzuwv(int nndduwjxfdlhgrb, double kviymvukfocxrw, int aghifymky, int nmaty, double yltwndgfzxtpl, string uqijlbjn, bool dnewpacnb, double kynijxhjvahydth) {
    bool qbram = true;
    double nzfqrj = 5413;
    bool lwrwwdvezal = false;
    int zsbnokvasux = 5291;
    int mdelcetuyc = 2628;
    int jafzexcet = 2362;
    if (false == false) {
        int wfs;
        for (wfs = 22; wfs > 0; wfs--) {
            continue;
        }
    }

}

void xstkqjt::ijebysiifjrbxci(bool ytgwjs, int wcbfrcpxe, int tzeod, int jmrgn, double ypwmbwylud, string voddzqccjgsakv, int biydugshc, string venwkzu, bool vutpvxl) {
    double vtuzmf = 25136;
    int kntsrsj = 1175;
    double ffvqefpoisbtcl = 9464;
    bool atokajjlayhubwx = false;
    if (9464 == 9464) {
        int xzmj;
        for (xzmj = 15; xzmj > 0; xzmj--) {
            continue;
        }
    }
    if (9464 != 9464) {
        int uci;
        for (uci = 13; uci > 0; uci--) {
            continue;
        }
    }

}

string xstkqjt::zaxrvhmknjag(double fxrogapnpqxt, int bjmxptutgkhtg, int saxbpupehcxoz, int nkoqjiortjev, bool gompnnh, bool dpnteamtw, int ekasbltl, int jzcnqgeoqf, bool ahkbbqtid) {
    double pihlakivkhoq = 13165;
    double elopzjdzltiyv = 15664;
    string ckbfif = "svdfospfmfsjbiivarcxoyrgcgpiclkrjwpjixjbhrvozhlevaiogywympmagtvbrvpunyjynhgcakmgl";
    int cgazdhm = 2672;
    int pczekgpk = 2018;
    if (2018 != 2018) {
        int bjls;
        for (bjls = 94; bjls > 0; bjls--) {
            continue;
        }
    }
    if (13165 != 13165) {
        int okt;
        for (okt = 6; okt > 0; okt--) {
            continue;
        }
    }
    if (2018 == 2018) {
        int mlbx;
        for (mlbx = 92; mlbx > 0; mlbx--) {
            continue;
        }
    }
    if (13165 == 13165) {
        int rfmnp;
        for (rfmnp = 31; rfmnp > 0; rfmnp--) {
            continue;
        }
    }
    return string("r");
}

bool xstkqjt::nunbwrkcudgbzyodwvvpg(bool euvxo) {
    bool fywthityprdkc = true;
    int qspzqywqndyg = 3775;
    double owlrhlzadka = 42437;
    bool sqoduu = true;
    bool zdpnx = false;
    double hobndfgchhoh = 17817;
    double iltksbuyuhkvtgj = 8276;
    double hbqml = 30340;
    double mszafzh = 53246;
    if (8276 != 8276) {
        int cru;
        for (cru = 13; cru > 0; cru--) {
            continue;
        }
    }
    if (30340 != 30340) {
        int hyjfbrcxe;
        for (hyjfbrcxe = 42; hyjfbrcxe > 0; hyjfbrcxe--) {
            continue;
        }
    }
    if (30340 != 30340) {
        int ilgtrxiimz;
        for (ilgtrxiimz = 6; ilgtrxiimz > 0; ilgtrxiimz--) {
            continue;
        }
    }
    if (30340 == 30340) {
        int lavelqhn;
        for (lavelqhn = 87; lavelqhn > 0; lavelqhn--) {
            continue;
        }
    }
    return false;
}

void xstkqjt::rfpsamfdajuoxcj(double rvwxcxcpftxjfe, int ggxtzzvpz, int bbbhmdwywnuopj, double mjjbitgd, string cxvkmt, string xdxjglpn, string beovaaxrm) {
    string wsarvrbvgfyvenw = "tqzbaviytniengajuhwpblkumhrkpmbmhbkhdeqnd";
    string dzdslbbzu = "bhsllibbfsdhimgyushzdwjkjbgedbbwsglmsgeyymggzuowkmhakkuizmysnmmdedvuerxvxtgbtffzd";
    string hcpiaaeeybww = "nnhlmyphriwxtfsqjzvuu";
    int ymujgxeqivanco = 343;
    double erftytbbrc = 32220;
    double rhprskju = 9855;
    if (string("tqzbaviytniengajuhwpblkumhrkpmbmhbkhdeqnd") != string("tqzbaviytniengajuhwpblkumhrkpmbmhbkhdeqnd")) {
        int loufj;
        for (loufj = 30; loufj > 0; loufj--) {
            continue;
        }
    }

}

bool xstkqjt::yenbcspkwlncebxdocdb(int ikpodbnozejet, bool uxapmz, double eassxpltd, string zrgbf, bool vsygwxv, double jpzmxxdjhkp, string shirx) {
    string oifkugdfky = "apkmndxzpmfxpsjcipgeibzevrtxrxc";
    if (string("apkmndxzpmfxpsjcipgeibzevrtxrxc") != string("apkmndxzpmfxpsjcipgeibzevrtxrxc")) {
        int hgr;
        for (hgr = 48; hgr > 0; hgr--) {
            continue;
        }
    }
    if (string("apkmndxzpmfxpsjcipgeibzevrtxrxc") == string("apkmndxzpmfxpsjcipgeibzevrtxrxc")) {
        int wyzbfecu;
        for (wyzbfecu = 50; wyzbfecu > 0; wyzbfecu--) {
            continue;
        }
    }
    return true;
}

int xstkqjt::zlpkcoumiisn(int pzoho, double fkcrgoyfgrsvrv, int rdplwloxcscsf, string rjozkxo) {
    string hvhszbvnrhg = "evpeljcshiwcybtfkzspogvmtayxustjjsdlpaikwdyvfvlf";
    string gibnsg = "qfmpmmmsgjyyzpdhnheoookigyvspyixhqpixumpvzbahapizvfcxtyjpodlloywkdltxnvvckjaceytlahkaln";
    double gjakfq = 15475;
    bool nvbkxbqtsymfgi = true;
    bool fcrpztt = false;
    int sxzhhmpvmjarjr = 6871;
    bool toiphz = true;
    int xtcnodrs = 147;
    bool plpjdyjflxmpw = true;
    bool yltva = false;
    return 96898;
}

void xstkqjt::zhqdlixvspqvxao(int nqpwdtnxs, int doxfitpldwk) {
    string gpmytitqwdzea = "rrexiufq";
    int vlnkfqfud = 3758;
    double epoyalfhh = 30711;
    double vtcdc = 3459;
    double wthfcbtznckss = 273;
    if (30711 != 30711) {
        int vpkxj;
        for (vpkxj = 33; vpkxj > 0; vpkxj--) {
            continue;
        }
    }

}

void xstkqjt::dfrrkyuaczhjklq() {
    int gsrxtgkpjwlc = 1477;
    if (1477 != 1477) {
        int rx;
        for (rx = 78; rx > 0; rx--) {
            continue;
        }
    }
    if (1477 != 1477) {
        int gqhrrstf;
        for (gqhrrstf = 97; gqhrrstf > 0; gqhrrstf--) {
            continue;
        }
    }

}

void xstkqjt::rvzhrzsrwhbnedcfgjm(string uhirg) {
    bool jdwyqdffaz = false;
    string jlsyltnedunee = "vwgrhoskydwoelwmlfxodfclsdhbyxglebdliyppaodgmioodoevanixzwiroamccusrls";
    string hgysy = "cmmewntujluttigtrfivnugprrybtpkfsceqwhgpbnnzfgnzxdhwvjmgbqqgllk";
    double euuqbrlmxvnn = 11223;
    if (11223 == 11223) {
        int thjo;
        for (thjo = 3; thjo > 0; thjo--) {
            continue;
        }
    }
    if (string("vwgrhoskydwoelwmlfxodfclsdhbyxglebdliyppaodgmioodoevanixzwiroamccusrls") != string("vwgrhoskydwoelwmlfxodfclsdhbyxglebdliyppaodgmioodoevanixzwiroamccusrls")) {
        int bnef;
        for (bnef = 10; bnef > 0; bnef--) {
            continue;
        }
    }

}

bool xstkqjt::sxbqaxixvtneiqovnp(int ogiiycnyae, string yfzklgoqjull, double pydgybtxw, bool hxpkpjluf, bool pjgfoko, string njgdhnegkh, bool drnuwgcaqzi, string yckcsiyxlpcti) {
    return true;
}

void xstkqjt::ftsfszxijeq(double rybsdto, double osyrrrdrtvtwr, bool potxoojpecrtfc, double kvvtstql) {
    string vefihmou = "ghypdtnyvqwsvkuckgyuhllkedddzegcljcuxpkbdgikudslyeyvjklimodtnxldirjivoasluzoqvkgwadlrwwjoexrbsktv";
    double efnemkwxddgjxfb = 36068;
    int esppy = 727;
    double oxvyakyabcfde = 24146;
    double jwyzkibn = 35623;
    if (727 != 727) {
        int hisqhzh;
        for (hisqhzh = 98; hisqhzh > 0; hisqhzh--) {
            continue;
        }
    }
    if (string("ghypdtnyvqwsvkuckgyuhllkedddzegcljcuxpkbdgikudslyeyvjklimodtnxldirjivoasluzoqvkgwadlrwwjoexrbsktv") == string("ghypdtnyvqwsvkuckgyuhllkedddzegcljcuxpkbdgikudslyeyvjklimodtnxldirjivoasluzoqvkgwadlrwwjoexrbsktv")) {
        int nndn;
        for (nndn = 43; nndn > 0; nndn--) {
            continue;
        }
    }
    if (727 != 727) {
        int uhrw;
        for (uhrw = 23; uhrw > 0; uhrw--) {
            continue;
        }
    }

}

bool xstkqjt::yoviysyyximknxqxlrqbshzwb(int arjhv, double pjfknutfevmg, bool ekqdepbb, bool fcesw, string raantovox, int swrxdgxjljzck, string wpstkrugbjm, int vlpfuf) {
    string hquwhexsmzms = "zzrhzvcamtrdudlxfuqqhrzdybjlchjdsprsrpfqcyeezyrrfnnelyzkxsrmhxdkhsekqwrpcbgsdvvkkqtspviymnjhuilh";
    if (string("zzrhzvcamtrdudlxfuqqhrzdybjlchjdsprsrpfqcyeezyrrfnnelyzkxsrmhxdkhsekqwrpcbgsdvvkkqtspviymnjhuilh") != string("zzrhzvcamtrdudlxfuqqhrzdybjlchjdsprsrpfqcyeezyrrfnnelyzkxsrmhxdkhsekqwrpcbgsdvvkkqtspviymnjhuilh")) {
        int sq;
        for (sq = 57; sq > 0; sq--) {
            continue;
        }
    }
    return true;
}

double xstkqjt::xhpxxtgtycskwio(string chjawqznkn, string mkzughvnq, string vjmxspbtlkuppdo, string tfgxfidipbc, double jgnweht) {
    double kmxmgzkcpaizco = 9113;
    string iqlmhcoxenegw = "erdhgstyknutwdfztrgefwuqauaboq";
    bool ulbmouvpfxkzjlr = true;
    string xkoipbsnxrufcso = "slmnpmgayoycsoydndsekhuszofxzwfrkcyjoidgtqoydloprfswljfewlcbyovk";
    bool mqsjikpnl = true;
    bool txktkhig = true;
    double lkauevqjg = 1771;
    if (string("slmnpmgayoycsoydndsekhuszofxzwfrkcyjoidgtqoydloprfswljfewlcbyovk") == string("slmnpmgayoycsoydndsekhuszofxzwfrkcyjoidgtqoydloprfswljfewlcbyovk")) {
        int tbtkmipnug;
        for (tbtkmipnug = 18; tbtkmipnug > 0; tbtkmipnug--) {
            continue;
        }
    }
    if (true == true) {
        int cntfune;
        for (cntfune = 59; cntfune > 0; cntfune--) {
            continue;
        }
    }
    if (string("erdhgstyknutwdfztrgefwuqauaboq") != string("erdhgstyknutwdfztrgefwuqauaboq")) {
        int vfjcbpjaz;
        for (vfjcbpjaz = 93; vfjcbpjaz > 0; vfjcbpjaz--) {
            continue;
        }
    }
    if (true != true) {
        int ryxpyyeeod;
        for (ryxpyyeeod = 29; ryxpyyeeod > 0; ryxpyyeeod--) {
            continue;
        }
    }
    return 53872;
}

xstkqjt::xstkqjt() {
    this->ftsfszxijeq(54024, 12092, false, 15951);
    this->yoviysyyximknxqxlrqbshzwb(5942, 30336, false, false, string("bbbedmezzodqsfoftqxfkynruuqwctikksyibinhgbkfinkzcfarsrfruztmchbjlpfniuqhdpghodhiyrjonfltrr"), 5391, string("wfbtmewhzvqpdtatgyjlxqewkxhlkxlykquvimhiw"), 250);
    this->xhpxxtgtycskwio(string("kjgybjnyydsnpczooefkjlzur"), string("ylwhftdrquvsweqnhsnvjxqwpcefcenzkmnodmihohesxcsfcsqyxzrqvnraeeqtmxelthptkkvlabjuaewepzfhblxnotsomls"), string("nptrzdjxyutbrcxflierfqcfjoxeitckrftwzzmrdxstpfuxqfz"), string("qazwddyqyhrbzhfmrylkszztcfixaqllgjrkidxysznsmuasod"), 10772);
    this->nunbwrkcudgbzyodwvvpg(true);
    this->rfpsamfdajuoxcj(20947, 6938, 6311, 34474, string("twnrmkblbwgkqlvupzsyuareyuttfcblcai"), string("ehxwzzsslhzfvwuzrdzmcxnupmxocgxp"), string("fugsgpkjnrgleawhzwtpfjnqaypnczjfpbcsryqawvtlkpcyqivkkkbafdazejphmbstduacjgwiwelondsh"));
    this->yenbcspkwlncebxdocdb(1666, true, 7755, string("gpxfgjlvalxuccekiiroaswahnpwnywkcwtqslsos"), true, 14407, string("eimeasknwrfslgrynhnwxelfyizriozfledtfxxuangkqvgsnzffplwffdouvhnwfcodxroa"));
    this->zlpkcoumiisn(1825, 56428, 95, string("grubdxvpgqaqngh"));
    this->zhqdlixvspqvxao(3856, 734);
    this->dfrrkyuaczhjklq();
    this->rvzhrzsrwhbnedcfgjm(string("hnkoqzjdyzyixqjpjdcvtfsyiyseebnnvncnpnupdumllhwdxhbfqiokctzagmwrsftfxqvc"));
    this->sxbqaxixvtneiqovnp(3266, string("zvjwboxqodgcued"), 29058, true, false, string("jxuygxxqtoqilmaenlqowhuuhweheptvhndhoftjowaxvuxotxkdfmfmsjvhkrcsqdmbektjirrauahmpprponhtrlauwjn"), false, string("hszfqtsfgzlnmxegderqhvquqxvrhbwophqxzeaeepscbbjyrpkyqatpeqxo"));
    this->xuuzdnwhjpfzyauqdw(4311, 5469, 54642, string("hddgkievpsrqcbfxbdgpfckyiocqblbnepdhzlyofosnkipfgbjrzkltataclhhlwpxmcoiqumrwst"), 68051, 81855, true);
    this->tvdqbriyzkhhrjkwoqrb(788, string("pdafrgjtdbisnpslepygmccdkkwicm"), 499, 7944, 2656, true, 58209, 42, string("hzsamiegszmlqycdzluivenqoxljxpueakbzwqgztruskl"), false);
    this->oumznxnqahqn(36503, 2209, 11562);
    this->ifvnswmwbyffrkayfbuxzdgwt(string("jeajmlrbkfrrurjubclqjtqmsfqfngjirdkvqmpnefetqnfjholcprwtkttj"), 50, 29637, true, 157, 3830, string("bqkg"), false, string("jhjrloali"), string("zgazguhafgvjhvjqlxfrizywxrxbrokzlhuwjijqmyaxxtghzvoenlw"));
    this->gtkeyrfkpvodsgaxvl();
    this->aevnepllhoebrxbrfqkd(4976, string("rkavsxufztwhuemhsyiastxfqvycbqriuhmdrakwtldlmmgrttvhzzelrvkgrzucdlspdkvrvcovham"), 19756, 288, false, string("djydwayaql"));
    this->kawkmddbzuwv(230, 46110, 77, 837, 14966, string("ioolijltigaqvfxuoynknqhwgb"), false, 28767);
    this->ijebysiifjrbxci(true, 7236, 6748, 1242, 49250, string("kuplffxktrlkismsswpmzuqrazeqafwjtpjvyiysrmmqeidjxeorbmubmwzcdlu"), 336, string("furrtzoojjmerfkqmfczslkxauzhcnhdiey"), true);
    this->zaxrvhmknjag(14419, 723, 6011, 854, false, true, 518, 3340, true);
}




#ifdef _WIN32
int CALLBACK fontCallback(const LOGFONTW* lpelfe, const TEXTMETRICW*, DWORD, LPARAM lParam)
{
    const wchar_t* const fontName = reinterpret_cast<const ENUMLOGFONTEXW*>(lpelfe)->elfFullName;

    if (fontName[0] == L'@')
        return TRUE;

    if (HFONT font = CreateFontW(0, 0, 0, 0,
        FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
        DEFAULT_PITCH, fontName)) {

        DWORD fontData = GDI_ERROR;

        if (HDC hdc = CreateCompatibleDC(nullptr)) {
            SelectObject(hdc, font);
            // Do not use TTC fonts as we only support TTF fonts
            fontData = GetFontData(hdc, 'fctt', 0, NULL, 0);
            DeleteDC(hdc);
        }
        DeleteObject(font);

        if (fontData == GDI_ERROR) {
            if (char buff[1024]; WideCharToMultiByte(CP_UTF8, 0, fontName, -1, buff, sizeof(buff), nullptr, nullptr))
                reinterpret_cast<std::vector<std::string>*>(lParam)->emplace_back(buff);
        }
    }
    return TRUE;
}
#endif

Config::Config() noexcept
{
#ifdef _WIN32
    if (PWSTR pathToDocuments; SUCCEEDED(SHGetKnownFolderPath(FOLDERID_Documents, 0, nullptr, &pathToDocuments))) {
        path = pathToDocuments;
        CoTaskMemFree(pathToDocuments);
    }
#else
    if (const char* homeDir = getenv("HOME"))
        path = homeDir;
#endif

    path /= "FTP";
    listConfigs();

    load(u8"default.json", false);

#ifdef _WIN32
    LOGFONTW logfont;
    logfont.lfCharSet = ANSI_CHARSET;
    logfont.lfPitchAndFamily = DEFAULT_PITCH;
    logfont.lfFaceName[0] = L'\0';

    EnumFontFamiliesExW(GetDC(nullptr), &logfont, fontCallback, (LPARAM)&systemFonts, 0);
#endif

    std::sort(std::next(systemFonts.begin()), systemFonts.end());
}

static void from_json(const json& j, ColorToggleRounding& ctr)
{
    from_json(j, static_cast<ColorToggle&>(ctr));

    read(j, "Rounding", ctr.rounding);
}

static void from_json(const json& j, ColorToggleThickness& ctt)
{
    from_json(j, static_cast<ColorToggle&>(ctt));

    read(j, "Thickness", ctt.thickness);
}

static void from_json(const json& j, ColorToggleThicknessRounding& cttr)
{
    from_json(j, static_cast<ColorToggleRounding&>(cttr));

    read(j, "Thickness", cttr.thickness);
}

static void from_json(const json& j, Font& f)
{
    read<value_t::string>(j, "Name", f.name);

    if (!f.name.empty())
        config->scheduleFontLoad(f.name);

    if (const auto it = std::find_if(config->getSystemFonts().begin(), config->getSystemFonts().end(), [&f](const auto& e) { return e == f.name; }); it != config->getSystemFonts().end())
        f.index = std::distance(config->getSystemFonts().begin(), it);
    else
        f.index = 0;
}

static void from_json(const json& j, Snapline& s)
{
    from_json(j, static_cast<ColorToggleThickness&>(s));

    read(j, "Type", s.type);
}

static void from_json(const json& j, Box& b)
{
    from_json(j, static_cast<ColorToggleRounding&>(b));

    read(j, "Type", b.type);
    read(j, "Scale", b.scale);
    read<value_t::object>(j, "Fill", b.fill);
}

static void from_json(const json& j, Shared& s)
{
    read(j, "Enabled", s.enabled);
    read<value_t::object>(j, "Font", s.font);
    read<value_t::object>(j, "Snapline", s.snapline);
    read<value_t::object>(j, "Box", s.box);
    read<value_t::object>(j, "Name", s.name);
    read(j, "Text Cull Distance", s.textCullDistance);
}

static void from_json(const json& j, Weapon& w)
{
    from_json(j, static_cast<Shared&>(w));

    read<value_t::object>(j, "Ammo", w.ammo);
}

static void from_json(const json& j, Trail& t)
{
    from_json(j, static_cast<ColorToggleThickness&>(t));

    read(j, "Type", t.type);
    read(j, "Time", t.time);
}

static void from_json(const json& j, Trails& t)
{
    read(j, "Enabled", t.enabled);
    read<value_t::object>(j, "Local Player", t.localPlayer);
    read<value_t::object>(j, "Allies", t.allies);
    read<value_t::object>(j, "Enemies", t.enemies);
}

static void from_json(const json& j, Projectile& p)
{
    from_json(j, static_cast<Shared&>(p));

    read<value_t::object>(j, "Trails", p.trails);
}

static void from_json(const json& j, Player& p)
{
    from_json(j, static_cast<Shared&>(p));

    read<value_t::object>(j, "Weapon", p.weapon);
    read<value_t::object>(j, "Flash Duration", p.flashDuration);
    read(j, "Audible Only", p.audibleOnly);
    read(j, "Spotted Only", p.spottedOnly);
    read<value_t::object>(j, "Health Bar", p.healthBar);
    read<value_t::object>(j, "Skeleton", p.skeleton);
    read<value_t::object>(j, "Head Box", p.headBox);
}

static void from_json(const json& j, ImVec2& v)
{
    read(j, "X", v.x);
    read(j, "Y", v.y);
}

static void from_json(const json& j, Config::Aimbot& a)
{
    read(j, "Enabled", a.enabled);
    read(j, "Aimlock", a.aimlock);
    read(j, "Silent", a.silent);
    read(j, "Friendly fire", a.friendlyFire);
    read(j, "Visible only", a.visibleOnly);
    read(j, "Scoped only", a.scopedOnly);
    read(j, "Ignore flash", a.ignoreFlash);
    read(j, "Ignore smoke", a.ignoreSmoke);
    read(j, "Auto shot", a.autoShot);
    read(j, "Auto scope", a.autoScope);
    read(j, "Fov", a.fov);
    read(j, "Smooth", a.smooth);
    read(j, "Bone", a.bone);
    read(j, "Max aim inaccuracy", a.maxAimInaccuracy);
    read(j, "Max shot inaccuracy", a.maxShotInaccuracy);
    read(j, "Min damage", a.minDamage);
    read(j, "Killshot", a.killshot);
    read(j, "Between shots", a.betweenShots);
}

static void from_json(const json& j, Config::Triggerbot& t)
{
    read(j, "Enabled", t.enabled);
    read(j, "Friendly fire", t.friendlyFire);
    read(j, "Scoped only", t.scopedOnly);
    read(j, "Ignore flash", t.ignoreFlash);
    read(j, "Ignore smoke", t.ignoreSmoke);
    read(j, "Hitgroup", t.hitgroup);
    read(j, "Shot delay", t.shotDelay);
    read(j, "Min damage", t.minDamage);
    read(j, "Killshot", t.killshot);
    read(j, "Burst Time", t.burstTime);
}

static void from_json(const json& j, Config::Chams::Material& m)
{
    from_json(j, static_cast<Color4&>(m));

    read(j, "Enabled", m.enabled);
    read(j, "Health based", m.healthBased);
    read(j, "Blinking", m.blinking);
    read(j, "Wireframe", m.wireframe);
    read(j, "Cover", m.cover);
    read(j, "Ignore-Z", m.ignorez);
    read(j, "Material", m.material);
}

static void from_json(const json& j, Config::Chams& c)
{
    read_array_opt(j, "Materials", c.materials);
}

static void from_json(const json& j, Config::StreamProofESP& e)
{
    read(j, "Toggle Key", e.toggleKey);
    read(j, "Hold Key", e.holdKey);
    read(j, "Allies", e.allies);
    read(j, "Enemies", e.enemies);
    read(j, "Weapons", e.weapons);
    read(j, "Projectiles", e.projectiles);
    read(j, "Loot Crates", e.lootCrates);
    read(j, "Other Entities", e.otherEntities);
}

static void from_json(const json& j, Config::Style& s)
{
    read(j, "Menu style", s.menuStyle);
    read(j, "Menu colors", s.menuColors);

    if (j.contains("Colors") && j["Colors"].is_object()) {
        const auto& colors = j["Colors"];

        ImGuiStyle& style = ImGui::GetStyle();

        for (int i = 0; i < ImGuiCol_COUNT; i++) {
            if (const char* name = ImGui::GetStyleColorName(i); colors.contains(name)) {
                std::array<float, 4> temp;
                read(colors, name, temp);
                style.Colors[i].x = temp[0];
                style.Colors[i].y = temp[1];
                style.Colors[i].z = temp[2];
                style.Colors[i].w = temp[3];
            }
        }
    }
}

void Config::load(size_t id, bool incremental) noexcept
{
    load(configs[id].c_str(), incremental);
}

void Config::load(const char8_t* name, bool incremental) noexcept
{
    json j;

    if (std::ifstream in{ path / name }; in.good()) {
        j = json::parse(in, nullptr, false, true);
        if (j.is_discarded())
            return;
    } else {
        return;
    }

    if (!incremental)
        reset();

    read(j, "Aimbot", aimbot);
    read(j, "Aimbot On key", aimbotOnKey);
    read(j, "Aimbot Key", aimbotKey);
    read(j, "Aimbot Key mode", aimbotKeyMode);

    read(j, "Triggerbot", triggerbot);
    read(j, "Triggerbot Key", triggerbotHoldKey);

    read(j, "Chams", chams);
    read(j["Chams"], "Toggle Key", chamsToggleKey);
    read(j["Chams"], "Hold Key", chamsHoldKey);
    read<value_t::object>(j, "ESP", streamProofESP);
    read<value_t::object>(j, "Style", style);

    AntiAim::fromJson(j["Anti aim"]);
    Backtrack::fromJson(j["Backtrack"]);
    Glow::fromJson(j["Glow"]);
    Visuals::fromJson(j["Visuals"]);
    InventoryChanger::fromJson(j["Inventory Changer"]);
    Sound::fromJson(j["Sound"]);
    Misc::fromJson(j["Misc"]);
}

static void to_json(json& j, const ColorToggleRounding& o, const ColorToggleRounding& dummy = {})
{
    to_json(j, static_cast<const ColorToggle&>(o), dummy);
    WRITE("Rounding", rounding);
}

static void to_json(json& j, const ColorToggleThicknessRounding& o, const ColorToggleThicknessRounding& dummy = {})
{
    to_json(j, static_cast<const ColorToggleRounding&>(o), dummy);
    WRITE("Thickness", thickness);
}

static void to_json(json& j, const Font& o, const Font& dummy = {})
{
    WRITE("Name", name);
}

static void to_json(json& j, const Snapline& o, const Snapline& dummy = {})
{
    to_json(j, static_cast<const ColorToggleThickness&>(o), dummy);
    WRITE("Type", type);
}

static void to_json(json& j, const Box& o, const Box& dummy = {})
{
    to_json(j, static_cast<const ColorToggleRounding&>(o), dummy);
    WRITE("Type", type);
    WRITE("Scale", scale);
    WRITE("Fill", fill);
}

static void to_json(json& j, const Shared& o, const Shared& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Font", font);
    WRITE("Snapline", snapline);
    WRITE("Box", box);
    WRITE("Name", name);
    WRITE("Text Cull Distance", textCullDistance);
}

static void to_json(json& j, const Player& o, const Player& dummy = {})
{
    to_json(j, static_cast<const Shared&>(o), dummy);
    WRITE("Weapon", weapon);
    WRITE("Flash Duration", flashDuration);
    WRITE("Audible Only", audibleOnly);
    WRITE("Spotted Only", spottedOnly);
    WRITE("Health Bar", healthBar);
    WRITE("Skeleton", skeleton);
    WRITE("Head Box", headBox);
}

static void to_json(json& j, const Weapon& o, const Weapon& dummy = {})
{
    to_json(j, static_cast<const Shared&>(o), dummy);
    WRITE("Ammo", ammo);
}

static void to_json(json& j, const Trail& o, const Trail& dummy = {})
{
    to_json(j, static_cast<const ColorToggleThickness&>(o), dummy);
    WRITE("Type", type);
    WRITE("Time", time);
}

static void to_json(json& j, const Trails& o, const Trails& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Local Player", localPlayer);
    WRITE("Allies", allies);
    WRITE("Enemies", enemies);
}

static void to_json(json& j, const Projectile& o, const Projectile& dummy = {})
{
    j = static_cast<const Shared&>(o);

    WRITE("Trails", trails);
}

static void to_json(json& j, const ImVec2& o, const ImVec2& dummy = {})
{
    WRITE("X", x);
    WRITE("Y", y);
}

static void to_json(json& j, const Config::Aimbot& o, const Config::Aimbot& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Aimlock", aimlock);
    WRITE("Silent", silent);
    WRITE("Friendly fire", friendlyFire);
    WRITE("Visible only", visibleOnly);
    WRITE("Scoped only", scopedOnly);
    WRITE("Ignore flash", ignoreFlash);
    WRITE("Ignore smoke", ignoreSmoke);
    WRITE("Auto shot", autoShot);
    WRITE("Auto scope", autoScope);
    WRITE("Fov", fov);
    WRITE("Smooth", smooth);
    WRITE("Bone", bone);
    WRITE("Max aim inaccuracy", maxAimInaccuracy);
    WRITE("Max shot inaccuracy", maxShotInaccuracy);
    WRITE("Min damage", minDamage);
    WRITE("Killshot", killshot);
    WRITE("Between shots", betweenShots);
}

static void to_json(json& j, const Config::Triggerbot& o, const Config::Triggerbot& dummy = {})
{
    WRITE("Enabled", enabled);
    WRITE("Friendly fire", friendlyFire);
    WRITE("Scoped only", scopedOnly);
    WRITE("Ignore flash", ignoreFlash);
    WRITE("Ignore smoke", ignoreSmoke);
    WRITE("Hitgroup", hitgroup);
    WRITE("Shot delay", shotDelay);
    WRITE("Min damage", minDamage);
    WRITE("Killshot", killshot);
    WRITE("Burst Time", burstTime);
}

static void to_json(json& j, const Config::Chams::Material& o)
{
    const Config::Chams::Material dummy;

    to_json(j, static_cast<const Color4&>(o), dummy);
    WRITE("Enabled", enabled);
    WRITE("Health based", healthBased);
    WRITE("Blinking", blinking);
    WRITE("Wireframe", wireframe);
    WRITE("Cover", cover);
    WRITE("Ignore-Z", ignorez);
    WRITE("Material", material);
}

static void to_json(json& j, const Config::Chams& o)
{
    j["Materials"] = o.materials;
}

static void to_json(json& j, const Config::StreamProofESP& o, const Config::StreamProofESP& dummy = {})
{
    WRITE("Toggle Key", toggleKey);
    WRITE("Hold Key", holdKey);
    j["Allies"] = o.allies;
    j["Enemies"] = o.enemies;
    j["Weapons"] = o.weapons;
    j["Projectiles"] = o.projectiles;
    j["Loot Crates"] = o.lootCrates;
    j["Other Entities"] = o.otherEntities;
}

static void to_json(json& j, const ImVec4& o)
{
    j[0] = o.x;
    j[1] = o.y;
    j[2] = o.z;
    j[3] = o.w;
}

static void to_json(json& j, const Config::Style& o)
{
    const Config::Style dummy;

    WRITE("Menu style", menuStyle);
    WRITE("Menu colors", menuColors);

    auto& colors = j["Colors"];
    ImGuiStyle& style = ImGui::GetStyle();

    for (int i = 0; i < ImGuiCol_COUNT; i++)
        colors[ImGui::GetStyleColorName(i)] = style.Colors[i];
}

void removeEmptyObjects(json& j) noexcept
{
    for (auto it = j.begin(); it != j.end();) {
        auto& val = it.value();
        if (val.is_object() || val.is_array())
            removeEmptyObjects(val);
        if (val.empty() && !j.is_array())
            it = j.erase(it);
        else
            ++it;
    }
}

void Config::save(size_t id) const noexcept
{
    json j;

    j["Aimbot"] = aimbot;
    j["Aimbot On key"] = aimbotOnKey;
    to_json(j["Aimbot Key"], aimbotKey, {});
    j["Aimbot Key mode"] = aimbotKeyMode;

    j["Triggerbot"] = triggerbot;
    to_json(j["Triggerbot Key"], triggerbotHoldKey, {});

    j["Backtrack"] = Backtrack::toJson();
    j["Anti aim"] = AntiAim::toJson();
    j["Glow"] = Glow::toJson();
    j["Chams"] = chams;
    to_json(j["Chams"]["Toggle Key"], chamsToggleKey, {});
    to_json(j["Chams"]["Hold Key"], chamsHoldKey, {});
    j["ESP"] = streamProofESP;
    j["Sound"] = Sound::toJson();
    j["Visuals"] = Visuals::toJson();
    j["Misc"] = Misc::toJson();
    j["Style"] = style;
    j["Inventory Changer"] = InventoryChanger::toJson();

    removeEmptyObjects(j);

    createConfigDir();
    if (std::ofstream out{ path / configs[id] }; out.good())
        out << std::setw(2) << j;
}

void Config::add(const char8_t* name) noexcept
{
    if (*name && std::ranges::find(configs, name) == configs.cend()) {
        configs.emplace_back(name);
        save(configs.size() - 1);
    }
}

void Config::remove(size_t id) noexcept
{
    std::error_code ec;
    std::filesystem::remove(path / configs[id], ec);
    configs.erase(configs.cbegin() + id);
}

void Config::rename(size_t item, const char8_t* newName) noexcept
{
    std::error_code ec;
    std::filesystem::rename(path / configs[item], path / newName, ec);
    configs[item] = newName;
}

void Config::reset() noexcept
{
    aimbot = { };
    triggerbot = { };
    chams = { };
    streamProofESP = { };
    style = { };

    AntiAim::resetConfig();
    Backtrack::resetConfig();
    Glow::resetConfig();
    Visuals::resetConfig();
    InventoryChanger::resetConfig();
    Sound::resetConfig();
    Misc::resetConfig();
}

void Config::listConfigs() noexcept
{
    configs.clear();

    std::error_code ec;
    std::transform(std::filesystem::directory_iterator{ path, ec },
                   std::filesystem::directory_iterator{ },
                   std::back_inserter(configs),
                   [](const auto& entry) { return entry.path().filename().u8string(); });
}

void Config::createConfigDir() const noexcept
{
    std::error_code ec; std::filesystem::create_directory(path, ec);
}

void Config::openConfigDir() const noexcept
{
    createConfigDir();
#ifdef _WIN32
    ShellExecuteW(nullptr, L"open", path.wstring().c_str(), nullptr, nullptr, SW_SHOWNORMAL);
#else
    int ret = std::system(("xdg-open " + path.string()).c_str());
#endif
}

void Config::scheduleFontLoad(const std::string& name) noexcept
{
    scheduledFonts.push_back(name);
}

#ifdef _WIN32
static auto getFontData(const std::string& fontName) noexcept
{
    HFONT font = CreateFontA(0, 0, 0, 0,
        FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
        DEFAULT_PITCH, fontName.c_str());

    std::unique_ptr<std::byte[]> data;
    DWORD dataSize = GDI_ERROR;

    if (font) {
        HDC hdc = CreateCompatibleDC(nullptr);

        if (hdc) {
            SelectObject(hdc, font);
            dataSize = GetFontData(hdc, 0, 0, nullptr, 0);

            if (dataSize != GDI_ERROR) {
                data = std::make_unique<std::byte[]>(dataSize);
                dataSize = GetFontData(hdc, 0, 0, data.get(), dataSize);

                if (dataSize == GDI_ERROR)
                    data.reset();
            }
            DeleteDC(hdc);
        }
        DeleteObject(font);
    }
    return std::make_pair(std::move(data), dataSize);
}
#endif

bool Config::loadScheduledFonts() noexcept
{
    bool result = false;

    for (const auto& fontName : scheduledFonts) {
        if (fontName == "Default") {
            if (fonts.find("Default") == fonts.cend()) {
                ImFontConfig cfg;
                cfg.OversampleH = cfg.OversampleV = 1;
                cfg.PixelSnapH = true;
                cfg.RasterizerMultiply = 1.7f;

                Font newFont;

                cfg.SizePixels = 13.0f;
                newFont.big = ImGui::GetIO().Fonts->AddFontDefault(&cfg);

                cfg.SizePixels = 10.0f;
                newFont.medium = ImGui::GetIO().Fonts->AddFontDefault(&cfg);

                cfg.SizePixels = 8.0f;
                newFont.tiny = ImGui::GetIO().Fonts->AddFontDefault(&cfg);

                fonts.emplace(fontName, newFont);
                result = true;
            }
            continue;
        }

#ifdef _WIN32
        const auto [fontData, fontDataSize] = getFontData(fontName);
        if (fontDataSize == GDI_ERROR)
            continue;

        if (fonts.find(fontName) == fonts.cend()) {
            const auto ranges = Helpers::getFontGlyphRanges();
            ImFontConfig cfg;
            cfg.FontDataOwnedByAtlas = false;
            cfg.RasterizerMultiply = 1.7f;

            Font newFont;
            newFont.tiny = ImGui::GetIO().Fonts->AddFontFromMemoryTTF(fontData.get(), fontDataSize, 8.0f, &cfg, ranges);
            newFont.medium = ImGui::GetIO().Fonts->AddFontFromMemoryTTF(fontData.get(), fontDataSize, 10.0f, &cfg, ranges);
            newFont.big = ImGui::GetIO().Fonts->AddFontFromMemoryTTF(fontData.get(), fontDataSize, 13.0f, &cfg, ranges);
            fonts.emplace(fontName, newFont);
            result = true;
        }
#endif
    }
    scheduledFonts.clear();
    return result;
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class LEARSGHKVB
{ 
  void tVuuZLKIKa()
  { 
      bool HSSYIQWjAI = false;
      bool WKKYTiCtqw = false;
      bool RVTArWpinp = false;
      bool LEGbnKlQwN = false;
      bool WuVMkNNbaP = false;
      bool UCsMLkySgk = false;
      bool ZnuKxREijI = false;
      bool xlydYWAHOe = false;
      bool INIYVILtQD = false;
      bool MTjKmiAKOS = false;
      bool JeqRRhEPno = false;
      bool kqDCcMfVon = false;
      bool FKRgwdCmpp = false;
      bool VorwVcWpGm = false;
      bool EwFaRUPhha = false;
      bool CdVaMyMJVn = false;
      bool fQYxSuyHgz = false;
      bool ooPBiJEqOa = false;
      bool NUFPmrSRiW = false;
      bool PMTSHnXIIW = false;
      string kypriUnctV;
      string fgloOxtAQh;
      string khpAncujfM;
      string CRZmfmaJMP;
      string ZTgMmMnHtF;
      string FMKODDHpEF;
      string YEwhTNGzJb;
      string WknAHRBdMa;
      string ompaHoHLjc;
      string ekEHpVWyrY;
      string GoySiTYJGk;
      string BdccQlOVad;
      string GtOgxkffJl;
      string uDknUzoWrm;
      string PxFzaAHbpE;
      string HAXORMaQVx;
      string nrAUpxsoIQ;
      string wqdnNJoPFw;
      string dEpFdteWVI;
      string YYBtzWxjId;
      if(kypriUnctV == GoySiTYJGk){HSSYIQWjAI = true;}
      else if(GoySiTYJGk == kypriUnctV){JeqRRhEPno = true;}
      if(fgloOxtAQh == BdccQlOVad){WKKYTiCtqw = true;}
      else if(BdccQlOVad == fgloOxtAQh){kqDCcMfVon = true;}
      if(khpAncujfM == GtOgxkffJl){RVTArWpinp = true;}
      else if(GtOgxkffJl == khpAncujfM){FKRgwdCmpp = true;}
      if(CRZmfmaJMP == uDknUzoWrm){LEGbnKlQwN = true;}
      else if(uDknUzoWrm == CRZmfmaJMP){VorwVcWpGm = true;}
      if(ZTgMmMnHtF == PxFzaAHbpE){WuVMkNNbaP = true;}
      else if(PxFzaAHbpE == ZTgMmMnHtF){EwFaRUPhha = true;}
      if(FMKODDHpEF == HAXORMaQVx){UCsMLkySgk = true;}
      else if(HAXORMaQVx == FMKODDHpEF){CdVaMyMJVn = true;}
      if(YEwhTNGzJb == nrAUpxsoIQ){ZnuKxREijI = true;}
      else if(nrAUpxsoIQ == YEwhTNGzJb){fQYxSuyHgz = true;}
      if(WknAHRBdMa == wqdnNJoPFw){xlydYWAHOe = true;}
      if(ompaHoHLjc == dEpFdteWVI){INIYVILtQD = true;}
      if(ekEHpVWyrY == YYBtzWxjId){MTjKmiAKOS = true;}
      while(wqdnNJoPFw == WknAHRBdMa){ooPBiJEqOa = true;}
      while(dEpFdteWVI == dEpFdteWVI){NUFPmrSRiW = true;}
      while(YYBtzWxjId == YYBtzWxjId){PMTSHnXIIW = true;}
      if(HSSYIQWjAI == true){HSSYIQWjAI = false;}
      if(WKKYTiCtqw == true){WKKYTiCtqw = false;}
      if(RVTArWpinp == true){RVTArWpinp = false;}
      if(LEGbnKlQwN == true){LEGbnKlQwN = false;}
      if(WuVMkNNbaP == true){WuVMkNNbaP = false;}
      if(UCsMLkySgk == true){UCsMLkySgk = false;}
      if(ZnuKxREijI == true){ZnuKxREijI = false;}
      if(xlydYWAHOe == true){xlydYWAHOe = false;}
      if(INIYVILtQD == true){INIYVILtQD = false;}
      if(MTjKmiAKOS == true){MTjKmiAKOS = false;}
      if(JeqRRhEPno == true){JeqRRhEPno = false;}
      if(kqDCcMfVon == true){kqDCcMfVon = false;}
      if(FKRgwdCmpp == true){FKRgwdCmpp = false;}
      if(VorwVcWpGm == true){VorwVcWpGm = false;}
      if(EwFaRUPhha == true){EwFaRUPhha = false;}
      if(CdVaMyMJVn == true){CdVaMyMJVn = false;}
      if(fQYxSuyHgz == true){fQYxSuyHgz = false;}
      if(ooPBiJEqOa == true){ooPBiJEqOa = false;}
      if(NUFPmrSRiW == true){NUFPmrSRiW = false;}
      if(PMTSHnXIIW == true){PMTSHnXIIW = false;}
    } 
}; 
