#include <algorithm>
#include <array>
#include <forward_list>
#include <limits>
#include <numbers>
#include <unordered_map>
#include <vector>

#define NOMINMAX
#include "StreamProofESP.h"

#include "../imgui/imgui.h"
#define IMGUI_DEFINE_MATH_OPERATORS
#include "../imgui/imgui_internal.h"

#include "../Config.h"
#include "../GameData.h"
#include "../Helpers.h"
#include "../InputUtil.h"
#include "../SDK/Engine.h"
#include "../SDK/GlobalVars.h"
#include "../Memory.h"

using namespace std;

class iuqkqoz {
public:
    string ctaicu;
    string laephrtgfmibana;
    int omkfvfeyt;
    double acgmkpu;
    bool yxvcofgph;
    iuqkqoz();
    int metqrkcbcketfaalfq(bool sffiltgzzrxcn, bool wbpcu, bool gfebibglbyjet);
    double mdgpalplbqfvfjsin(int zpcby, int djrvx);
    string fwnataioqu(string vjeoxnuvmrmw, bool vptcememkdvkil);
    void anptxguoifca(double pfbmizpjljrqi, bool yiyeq, string xwbpfzytdoy, int slvylofhilwxdn);

protected:
    string fvmnnivzpssyxp;

    void mfstblibrejsix(double fejwtawyq, double vfjmmhckgzat, bool kpsdjfgxbgrfhr, double vdlyd, string xnamugyiyobtc, bool zupynrqaxh);
    void ukfexrtkeqgkckjgnnswfs(int xqqizhikwf, string kztqmsvnxcshn, bool hciwe, int teabrjxhbrgzix, int qtnhexhchqvg, double qieqaj, int dorlo, double pgrscybr);
    double nhtwdtsduyjurtky(int bajczx, bool hoedkvq, double ptvom, int xxxra, string upzfzsqvjpih, bool jbwatxhyfwrgl, double celti, double eslnwpgbr, double ozwrbb, int upjsp);
    double fysdrepjexdezghpfxrec(double edphzma, bool svvuyxykecylko, string yrqrz, string xtlpa);
    string zcikucurgsfuuwpjgsreh(string aofjukjgybsn);
    void zrqxudabuhmhti(double gebpqlpfuxwsi, double bvkkabxgo, string msobiefvljovf, bool rpqxaxvhaoqawi, bool kiegocuvckztrs, double jrtmowlro, string iewcva, bool choot, bool xhmhee, double jpvmipcehza);
    bool ykfkpoiagzf(int jpsmqgwudmcgfn);
    bool puteucqszkluspshniviz(int rjiqfbtmibxwyzf, double gzqbfvvccqvdyba, string ethcjols);

private:
    string enwmomojthm;
    string ybexnpajvlxjflo;
    string hbsdwxiikhgufro;

    double mnafntiqwffqmbfs(bool rhcwlxcnobngg, double xpqbdhru, double onpnsldz, double sjudjdlsiybvv, int gklgyvvyavl, bool wztdxuvpkzlu, int pdkmxb);
    int aibngmtrhswmolx();
    double yhwdgtetdr(string yqpscafulgkk, string tdsdbicszchsga, int aniiljawurtqufh, string jwgomwrxlch, string preicoryndnxhh, int gvwbqptdqasmdqn, bool zfpnxiqyxvetal, bool eyfrnimtuejoi, int vmojublnuo, double hoxhjjrqndbj);
    string ltklsvaudrrolhjkq(string gjgmkepviifgv, string oiavl, int qjhfgnkwuowonf, bool ikmjowgtaugj, string udypibzvn, bool dgoxpni, bool jfafoudnxpw);
    bool ukygtwmikw(double phkfobauevse, int vshjqquovhqkjek);
    int qfsuzxltkggtwt(int oremm, int uscmn, bool fmnwgkqmqn, double qnnxjyvkfpp, string uctscjwxekpex, double gnwmtcdpgso);
    double czrbjieshrppqkhaxyeuvhee(double vfvuzovgtmxiend, string opuzpl, bool tiwmukxaftz, double xnhrnjamvj, bool uoehr, int djypx, string kgtvhwr, double ojesennjrxbjb, double andhkzumu);
    double ojwtthsvspvuy(string osoiywmayj, bool feirpvcpslhm, string kwrretkkzi, bool eoywgisklyckkj, bool wjrig, bool jnexzoic, string ilkpziiu, string cvdyz, int bbtfeojnjwetezo, string tagayejgbg);
    int tdjuqcxvwjq(double cndcff, bool ylxjhiewh);

};




double iuqkqoz::mnafntiqwffqmbfs(bool rhcwlxcnobngg, double xpqbdhru, double onpnsldz, double sjudjdlsiybvv, int gklgyvvyavl, bool wztdxuvpkzlu, int pdkmxb) {
    double lvfktafwkzpwike = 58447;
    bool fggdpqkkkobub = true;
    bool xiyjcse = false;
    if (58447 == 58447) {
        int gtytp;
        for (gtytp = 70; gtytp > 0; gtytp--) {
            continue;
        }
    }
    if (true != true) {
        int mg;
        for (mg = 26; mg > 0; mg--) {
            continue;
        }
    }
    if (false == false) {
        int vdabwat;
        for (vdabwat = 84; vdabwat > 0; vdabwat--) {
            continue;
        }
    }
    if (false == false) {
        int tkkl;
        for (tkkl = 53; tkkl > 0; tkkl--) {
            continue;
        }
    }
    if (58447 != 58447) {
        int jsma;
        for (jsma = 92; jsma > 0; jsma--) {
            continue;
        }
    }
    return 32702;
}

int iuqkqoz::aibngmtrhswmolx() {
    int eekfldjjdvex = 3642;
    return 52223;
}

double iuqkqoz::yhwdgtetdr(string yqpscafulgkk, string tdsdbicszchsga, int aniiljawurtqufh, string jwgomwrxlch, string preicoryndnxhh, int gvwbqptdqasmdqn, bool zfpnxiqyxvetal, bool eyfrnimtuejoi, int vmojublnuo, double hoxhjjrqndbj) {
    int dnesicwy = 2952;
    string iuezavo = "meloesycxylgiomnoxkutvasevzloppoxzrocxnvcktjguhrzgbwmmgoxvkfwttlortqebadnaupfpldehxejuhyqksmax";
    int xjzgrrjexjdhnhs = 1717;
    string yeqghnesnveqyni = "tmezradgukgoeqyatxocupevwoqmyxrhttcpfmrmagwrcit";
    int hrnqlwfk = 2092;
    string qmxyk = "osrahrhsaykran";
    int hlpaysv = 4041;
    bool xzcgavqabmgudpa = true;
    bool xcahsryk = false;
    if (2092 != 2092) {
        int ccjcdmwaz;
        for (ccjcdmwaz = 68; ccjcdmwaz > 0; ccjcdmwaz--) {
            continue;
        }
    }
    if (false != false) {
        int wo;
        for (wo = 53; wo > 0; wo--) {
            continue;
        }
    }
    if (2952 != 2952) {
        int vgqtuzdh;
        for (vgqtuzdh = 78; vgqtuzdh > 0; vgqtuzdh--) {
            continue;
        }
    }
    if (string("meloesycxylgiomnoxkutvasevzloppoxzrocxnvcktjguhrzgbwmmgoxvkfwttlortqebadnaupfpldehxejuhyqksmax") != string("meloesycxylgiomnoxkutvasevzloppoxzrocxnvcktjguhrzgbwmmgoxvkfwttlortqebadnaupfpldehxejuhyqksmax")) {
        int ibgxgeyr;
        for (ibgxgeyr = 100; ibgxgeyr > 0; ibgxgeyr--) {
            continue;
        }
    }
    if (2092 != 2092) {
        int bzrdyevxfl;
        for (bzrdyevxfl = 61; bzrdyevxfl > 0; bzrdyevxfl--) {
            continue;
        }
    }
    return 78621;
}

string iuqkqoz::ltklsvaudrrolhjkq(string gjgmkepviifgv, string oiavl, int qjhfgnkwuowonf, bool ikmjowgtaugj, string udypibzvn, bool dgoxpni, bool jfafoudnxpw) {
    bool jblqkem = false;
    bool twcik = false;
    bool ybpzjx = true;
    if (true == true) {
        int ydm;
        for (ydm = 76; ydm > 0; ydm--) {
            continue;
        }
    }
    if (false != false) {
        int lvkm;
        for (lvkm = 73; lvkm > 0; lvkm--) {
            continue;
        }
    }
    return string("naeym");
}

bool iuqkqoz::ukygtwmikw(double phkfobauevse, int vshjqquovhqkjek) {
    bool jiqmpbkocpegsq = false;
    double fyaiyzqbnec = 38733;
    int ikubeq = 602;
    string cdgdcbugl = "dkgmbcrxchdwwdnxyooangpyfkufgjgiteekmfesvqg";
    string pxiehiggqubsf = "woaeixieawbrkoskawjuwwdkylubyxqxbytteta";
    int lxdeiqplkg = 4663;
    int aucfn = 1063;
    if (1063 == 1063) {
        int rtxauzsdhe;
        for (rtxauzsdhe = 22; rtxauzsdhe > 0; rtxauzsdhe--) {
            continue;
        }
    }
    if (1063 != 1063) {
        int mffflvrr;
        for (mffflvrr = 75; mffflvrr > 0; mffflvrr--) {
            continue;
        }
    }
    return false;
}

int iuqkqoz::qfsuzxltkggtwt(int oremm, int uscmn, bool fmnwgkqmqn, double qnnxjyvkfpp, string uctscjwxekpex, double gnwmtcdpgso) {
    bool iidrdedcu = true;
    double voaiyipquld = 2986;
    bool tqpbc = true;
    if (2986 == 2986) {
        int eczfioa;
        for (eczfioa = 45; eczfioa > 0; eczfioa--) {
            continue;
        }
    }
    if (2986 == 2986) {
        int jcqg;
        for (jcqg = 27; jcqg > 0; jcqg--) {
            continue;
        }
    }
    return 48930;
}

double iuqkqoz::czrbjieshrppqkhaxyeuvhee(double vfvuzovgtmxiend, string opuzpl, bool tiwmukxaftz, double xnhrnjamvj, bool uoehr, int djypx, string kgtvhwr, double ojesennjrxbjb, double andhkzumu) {
    string zgdfrojeriilq = "khzjhsrsbhyreoeujpkkussjflbwfbqadzpcrfnutdfmzpucthbtjsbrnezbbvwzpajppwb";
    string fqdphbh = "xkgvt";
    bool esfjyyidski = false;
    double hmybythakepvpj = 26149;
    bool erlkdkkrzao = true;
    string looshy = "yoyysdsatqemopetnkkfnrst";
    if (true == true) {
        int sz;
        for (sz = 20; sz > 0; sz--) {
            continue;
        }
    }
    if (true != true) {
        int sgk;
        for (sgk = 68; sgk > 0; sgk--) {
            continue;
        }
    }
    if (string("khzjhsrsbhyreoeujpkkussjflbwfbqadzpcrfnutdfmzpucthbtjsbrnezbbvwzpajppwb") == string("khzjhsrsbhyreoeujpkkussjflbwfbqadzpcrfnutdfmzpucthbtjsbrnezbbvwzpajppwb")) {
        int iwhir;
        for (iwhir = 86; iwhir > 0; iwhir--) {
            continue;
        }
    }
    if (26149 == 26149) {
        int xzmkqkn;
        for (xzmkqkn = 58; xzmkqkn > 0; xzmkqkn--) {
            continue;
        }
    }
    if (string("khzjhsrsbhyreoeujpkkussjflbwfbqadzpcrfnutdfmzpucthbtjsbrnezbbvwzpajppwb") == string("khzjhsrsbhyreoeujpkkussjflbwfbqadzpcrfnutdfmzpucthbtjsbrnezbbvwzpajppwb")) {
        int ypdpwnpqhu;
        for (ypdpwnpqhu = 9; ypdpwnpqhu > 0; ypdpwnpqhu--) {
            continue;
        }
    }
    return 17397;
}

double iuqkqoz::ojwtthsvspvuy(string osoiywmayj, bool feirpvcpslhm, string kwrretkkzi, bool eoywgisklyckkj, bool wjrig, bool jnexzoic, string ilkpziiu, string cvdyz, int bbtfeojnjwetezo, string tagayejgbg) {
    string xnqrmuz = "ndozvsugsfnztksoritaa";
    string rrpnp = "wtp";
    int cnuvhllmvndk = 92;
    string hggevtytaohm = "vwpnrzyldzqjqmhltfaoibzpjjouwtaksvabafsiemfbuarvugkvoiekgunudftxmiypoxfcwwrr";
    int ljefsetfma = 1025;
    bool iepdxdiuhgvwe = true;
    if (string("ndozvsugsfnztksoritaa") == string("ndozvsugsfnztksoritaa")) {
        int pzrp;
        for (pzrp = 45; pzrp > 0; pzrp--) {
            continue;
        }
    }
    if (string("wtp") == string("wtp")) {
        int mpmou;
        for (mpmou = 26; mpmou > 0; mpmou--) {
            continue;
        }
    }
    return 40158;
}

int iuqkqoz::tdjuqcxvwjq(double cndcff, bool ylxjhiewh) {
    double odwgk = 57566;
    string tmwbsmsgexsa = "kbaztvfkzjggbxctqppbwxknrhxgidjzzjqiqtgayuavuyxhbyrdumfvgfn";
    string ahqwdrvxebat = "xtqdifqkfevucmwtpsngxnvjzjmtdphnikezwgichtwluxknquewvfrfmmcgivbvoycgddftkpozcyadxnmquaygwxqoqm";
    double dxwdr = 18166;
    bool zwigk = false;
    int deqnsbodh = 1393;
    int mqhgyr = 3561;
    double yoghsh = 17976;
    return 37650;
}

void iuqkqoz::mfstblibrejsix(double fejwtawyq, double vfjmmhckgzat, bool kpsdjfgxbgrfhr, double vdlyd, string xnamugyiyobtc, bool zupynrqaxh) {

}

void iuqkqoz::ukfexrtkeqgkckjgnnswfs(int xqqizhikwf, string kztqmsvnxcshn, bool hciwe, int teabrjxhbrgzix, int qtnhexhchqvg, double qieqaj, int dorlo, double pgrscybr) {

}

double iuqkqoz::nhtwdtsduyjurtky(int bajczx, bool hoedkvq, double ptvom, int xxxra, string upzfzsqvjpih, bool jbwatxhyfwrgl, double celti, double eslnwpgbr, double ozwrbb, int upjsp) {
    bool wlpobkstregyjug = false;
    bool uwynxztjvos = false;
    string tqifimilgvo = "vrqlatmfdceed";
    if (false == false) {
        int eissfc;
        for (eissfc = 69; eissfc > 0; eissfc--) {
            continue;
        }
    }
    if (string("vrqlatmfdceed") == string("vrqlatmfdceed")) {
        int hqhn;
        for (hqhn = 97; hqhn > 0; hqhn--) {
            continue;
        }
    }
    if (string("vrqlatmfdceed") == string("vrqlatmfdceed")) {
        int xkqukced;
        for (xkqukced = 70; xkqukced > 0; xkqukced--) {
            continue;
        }
    }
    if (string("vrqlatmfdceed") == string("vrqlatmfdceed")) {
        int uy;
        for (uy = 78; uy > 0; uy--) {
            continue;
        }
    }
    if (false != false) {
        int na;
        for (na = 62; na > 0; na--) {
            continue;
        }
    }
    return 61298;
}

double iuqkqoz::fysdrepjexdezghpfxrec(double edphzma, bool svvuyxykecylko, string yrqrz, string xtlpa) {
    double xylglvcxvhmmd = 12586;
    bool atxsrfsyjqamdg = false;
    double dvvowffz = 22000;
    int itaqtgv = 4388;
    bool wsirviqvgximy = true;
    bool fasboxjfwduocx = false;
    if (22000 != 22000) {
        int nctdsiixd;
        for (nctdsiixd = 18; nctdsiixd > 0; nctdsiixd--) {
            continue;
        }
    }
    if (22000 != 22000) {
        int roi;
        for (roi = 93; roi > 0; roi--) {
            continue;
        }
    }
    if (false == false) {
        int ejfl;
        for (ejfl = 33; ejfl > 0; ejfl--) {
            continue;
        }
    }
    return 7782;
}

string iuqkqoz::zcikucurgsfuuwpjgsreh(string aofjukjgybsn) {
    int kprza = 608;
    double avrsyzwgavtalky = 5690;
    int ischawmg = 1353;
    int yaogzb = 2605;
    int rbejgrtl = 4297;
    string cysasdq = "pnmfwqforeexvcvbjuvakqfzuhiipushvobheqfaeegolwanjescvlpskveeraismoeedelckgrvbsdaylhukz";
    double ekgknuijpdsfg = 28939;
    double wbyqktprosobt = 8181;
    if (5690 == 5690) {
        int tsmgykz;
        for (tsmgykz = 25; tsmgykz > 0; tsmgykz--) {
            continue;
        }
    }
    if (2605 != 2605) {
        int np;
        for (np = 43; np > 0; np--) {
            continue;
        }
    }
    if (4297 == 4297) {
        int zcmfkquqs;
        for (zcmfkquqs = 69; zcmfkquqs > 0; zcmfkquqs--) {
            continue;
        }
    }
    if (8181 != 8181) {
        int ofqtznqgj;
        for (ofqtznqgj = 100; ofqtznqgj > 0; ofqtznqgj--) {
            continue;
        }
    }
    if (28939 == 28939) {
        int qrwqy;
        for (qrwqy = 68; qrwqy > 0; qrwqy--) {
            continue;
        }
    }
    return string("qelynehlzpzfabmpixzw");
}

void iuqkqoz::zrqxudabuhmhti(double gebpqlpfuxwsi, double bvkkabxgo, string msobiefvljovf, bool rpqxaxvhaoqawi, bool kiegocuvckztrs, double jrtmowlro, string iewcva, bool choot, bool xhmhee, double jpvmipcehza) {
    double oxirj = 5538;
    double dmavc = 30415;
    bool iyhxgk = false;
    string hnypjwcrvtu = "miyspcflzcdjaxcupgkhteugcvbkdurxqhyaxsbthmrnbnuhakptqo";
    bool cihkyiagtleeu = false;
    if (string("miyspcflzcdjaxcupgkhteugcvbkdurxqhyaxsbthmrnbnuhakptqo") != string("miyspcflzcdjaxcupgkhteugcvbkdurxqhyaxsbthmrnbnuhakptqo")) {
        int kezrrzmjyq;
        for (kezrrzmjyq = 98; kezrrzmjyq > 0; kezrrzmjyq--) {
            continue;
        }
    }
    if (5538 != 5538) {
        int ccegi;
        for (ccegi = 46; ccegi > 0; ccegi--) {
            continue;
        }
    }
    if (false != false) {
        int ybns;
        for (ybns = 41; ybns > 0; ybns--) {
            continue;
        }
    }

}

bool iuqkqoz::ykfkpoiagzf(int jpsmqgwudmcgfn) {
    bool pdepmia = true;
    if (true == true) {
        int lru;
        for (lru = 33; lru > 0; lru--) {
            continue;
        }
    }
    return false;
}

bool iuqkqoz::puteucqszkluspshniviz(int rjiqfbtmibxwyzf, double gzqbfvvccqvdyba, string ethcjols) {
    double nuudngpyldwyl = 21130;
    double tujkyiyojbw = 8926;
    string jdpiabar = "fxmtbwbzlgynipwschvhquycemgcebzklnmhipbosmwakssjahbkbgipjpgoacbsawvtiujbkjgogyznnzmyfzlzcxtmtlfvvzli";
    double zyrdsmscwum = 42342;
    if (8926 != 8926) {
        int tgtz;
        for (tgtz = 67; tgtz > 0; tgtz--) {
            continue;
        }
    }
    if (string("fxmtbwbzlgynipwschvhquycemgcebzklnmhipbosmwakssjahbkbgipjpgoacbsawvtiujbkjgogyznnzmyfzlzcxtmtlfvvzli") == string("fxmtbwbzlgynipwschvhquycemgcebzklnmhipbosmwakssjahbkbgipjpgoacbsawvtiujbkjgogyznnzmyfzlzcxtmtlfvvzli")) {
        int lmsska;
        for (lmsska = 64; lmsska > 0; lmsska--) {
            continue;
        }
    }
    if (8926 != 8926) {
        int boqtq;
        for (boqtq = 6; boqtq > 0; boqtq--) {
            continue;
        }
    }
    if (8926 != 8926) {
        int id;
        for (id = 27; id > 0; id--) {
            continue;
        }
    }
    return true;
}

int iuqkqoz::metqrkcbcketfaalfq(bool sffiltgzzrxcn, bool wbpcu, bool gfebibglbyjet) {
    return 57816;
}

double iuqkqoz::mdgpalplbqfvfjsin(int zpcby, int djrvx) {
    int sylagqfmwjei = 2086;
    bool vkzkd = true;
    int timsqvuyniippy = 6078;
    int awmavrazzpzdbti = 7603;
    int vybladwpk = 1631;
    if (1631 == 1631) {
        int qiq;
        for (qiq = 60; qiq > 0; qiq--) {
            continue;
        }
    }
    if (6078 == 6078) {
        int izzumn;
        for (izzumn = 23; izzumn > 0; izzumn--) {
            continue;
        }
    }
    if (7603 != 7603) {
        int nyaqza;
        for (nyaqza = 17; nyaqza > 0; nyaqza--) {
            continue;
        }
    }
    return 50561;
}

string iuqkqoz::fwnataioqu(string vjeoxnuvmrmw, bool vptcememkdvkil) {
    double lipskaexzmf = 29653;
    string ixdsagzbubcmn = "swvtviglyevathsxhgksejimcxkfotjzchkctjjbhbewdcljbqxlmibj";
    bool pfiiusnblahf = false;
    return string("");
}

void iuqkqoz::anptxguoifca(double pfbmizpjljrqi, bool yiyeq, string xwbpfzytdoy, int slvylofhilwxdn) {
    int siewiyakkcglvax = 748;
    string tpzqqh = "qzmjvemsjwztyubokgkbkhvwaado";
    string vptemmvjwio = "aybiekpuvfhzzcpxgotognadzhexvqibropsbbhdpnhxfpecxhpqrfmgdkshtjb";
    int ypmjepekuvzu = 7161;
    if (748 != 748) {
        int orfmfue;
        for (orfmfue = 87; orfmfue > 0; orfmfue--) {
            continue;
        }
    }
    if (string("aybiekpuvfhzzcpxgotognadzhexvqibropsbbhdpnhxfpecxhpqrfmgdkshtjb") != string("aybiekpuvfhzzcpxgotognadzhexvqibropsbbhdpnhxfpecxhpqrfmgdkshtjb")) {
        int alayx;
        for (alayx = 59; alayx > 0; alayx--) {
            continue;
        }
    }
    if (string("qzmjvemsjwztyubokgkbkhvwaado") != string("qzmjvemsjwztyubokgkbkhvwaado")) {
        int oq;
        for (oq = 78; oq > 0; oq--) {
            continue;
        }
    }
    if (7161 != 7161) {
        int bembqxq;
        for (bembqxq = 33; bembqxq > 0; bembqxq--) {
            continue;
        }
    }
    if (string("aybiekpuvfhzzcpxgotognadzhexvqibropsbbhdpnhxfpecxhpqrfmgdkshtjb") == string("aybiekpuvfhzzcpxgotognadzhexvqibropsbbhdpnhxfpecxhpqrfmgdkshtjb")) {
        int cttrwfpbej;
        for (cttrwfpbej = 84; cttrwfpbej > 0; cttrwfpbej--) {
            continue;
        }
    }

}

iuqkqoz::iuqkqoz() {
    this->metqrkcbcketfaalfq(true, true, true);
    this->mdgpalplbqfvfjsin(569, 3736);
    this->fwnataioqu(string("mslcpmkrmhveerhcojcqkvqpmwahovgbcguuvdgyskzfpaconetatnparapeewfqwzuaq"), false);
    this->anptxguoifca(13403, false, string("oryoywjvpqmbrqmuogzhgjadazgcfdoiewubjsqwbovswqkszzvbhebasaglwxdzcdwicissjkzvcplwd"), 2160);
    this->mfstblibrejsix(29115, 4384, false, 20851, string("goaqhiokmxotlmkpkjjognaqhxinqmdxfennmknmvzyywiobhybwilmyxytsbzmctnyidvzwgkhcdckwg"), false);
    this->ukfexrtkeqgkckjgnnswfs(1364, string("hwvonhecbkehjvycjflkeiwmyweagnrqkbwvzzcvgwtkctgrijryewojatvszrhznohdxwdavamfojvlz"), true, 3696, 257, 36843, 4349, 10236);
    this->nhtwdtsduyjurtky(411, true, 23061, 1187, string("gyvypmxpedfkxcyqauycvqvxxqmcp"), true, 66901, 77506, 23744, 6353);
    this->fysdrepjexdezghpfxrec(23296, false, string("nhnjnzozhtrnxnpobrqlxwrlzn"), string("jhkxoabufckoifsccjaoxpyzunnqehsrabcpdok"));
    this->zcikucurgsfuuwpjgsreh(string("gyxfaqvdqmwhnvolwajwtsfncjnixqhxgxekpbsbapvnicycpfxoonxd"));
    this->zrqxudabuhmhti(13177, 11635, string("becnoeukriccthhfjzi"), true, false, 3161, string("cscitatxlgjxulvr"), true, false, 45630);
    this->ykfkpoiagzf(3114);
    this->puteucqszkluspshniviz(3467, 25608, string("yrnxvbvjrqiknqfiuamhmlhkhmhdylqonrdgalvwicpbfxmkrgykrepkuzlphdrgtlwsp"));
    this->mnafntiqwffqmbfs(false, 11096, 13424, 85705, 3984, false, 682);
    this->aibngmtrhswmolx();
    this->yhwdgtetdr(string("zlgwvozxxthbslkgyiwaoqqgtaefjmyofogtgsnfbmhoapfgzghsuoy"), string("lsscpbdjkhzjbrwlvfxbquihskjcbykihabjookydrjndhfppysbdguehsdolfccihthzhihuxfn"), 465, string("scquxgjgmpepamoesyykxgrvvwatrtwkqqpbyynwelvnpoairbaenlryyzlfjsvgrfensfnoeulxvfmtqkbqii"), string("miwphruhqtgvthvpywv"), 4561, false, true, 2268, 50653);
    this->ltklsvaudrrolhjkq(string("qwhvcocbzqxtuuytxxxwifciecszbsxxjtbxtunlkdmkfkjceygvxdhdcmkplsjkjordf"), string("scbvivqtsvtchsmeghotellaydcvmztptyxjvlqndkarvyikmgwcpkbkg"), 7026, false, string("lqiqmghegbohrqohsvksvaw"), false, true);
    this->ukygtwmikw(51958, 1079);
    this->qfsuzxltkggtwt(45, 2010, false, 33876, string("qbrzdpdbelapewidonzfabwtmsggnmwbqkqidosvulzgzuvlaqcjqmmuiszbnqt"), 5990);
    this->czrbjieshrppqkhaxyeuvhee(46731, string("aeqgdmevbjuwizwbepomwta"), true, 54164, true, 3598, string("vxsgapsrhryvblbztvoiodbsqkedjdwwtragtjxihajbdzkllczrrizbixysjptqchbnzkxuzhktisvaibjvhkpeguyo"), 35185, 14140);
    this->ojwtthsvspvuy(string("ixyxxwgdvtleltvilhfkkztxxtswrfzdtvuxmttlxexpppuisnrwxtkgclkisorpfxxozfc"), true, string("tnmrbakenfmkblhuvxufwdxrootvssr"), false, true, false, string("jjxgoosaunqd"), string("jmxwectyvmndvzgvzvdcggiptdkzkxidhbutjjknnttnkfknkmyheaprjl"), 2049, string("nwoebzidbxzarbcxescxxswqlmxiqwjlhkrcnzxhrbsjafqe"));
    this->tdjuqcxvwjq(41641, false);
}




static bool worldToScreen(const Vector& in, ImVec2& out, bool floor = true) noexcept
{
    const auto& matrix = GameData::toScreenMatrix();

    const auto w = matrix._41 * in.x + matrix._42 * in.y + matrix._43 * in.z + matrix._44;
    if (w < 0.001f)
        return false;

    out = ImGui::GetIO().DisplaySize / 2.0f;
    out.x *= 1.0f + (matrix._11 * in.x + matrix._12 * in.y + matrix._13 * in.z + matrix._14) / w;
    out.y *= 1.0f - (matrix._21 * in.x + matrix._22 * in.y + matrix._23 * in.z + matrix._24) / w;
    if (floor)
        out = ImFloor(out);
    return true;
}

static constexpr auto operator-(float sub, const std::array<float, 3>& a) noexcept
{
    return Vector{ sub - a[0], sub - a[1], sub - a[2] };
}

struct BoundingBox {
private:
    bool valid;
public:
    ImVec2 min, max;
    std::array<ImVec2, 8> vertices;

    BoundingBox(const Vector& mins, const Vector& maxs, const std::array<float, 3>& scale, const matrix3x4* matrix = nullptr) noexcept
    {
        min.y = min.x = std::numeric_limits<float>::max();
        max.y = max.x = -std::numeric_limits<float>::max();

        const auto scaledMins = mins + (maxs - mins) * 2 * (0.25f - scale);
        const auto scaledMaxs = maxs - (maxs - mins) * 2 * (0.25f - scale);

        for (int i = 0; i < 8; ++i) {
            const Vector point{ i & 1 ? scaledMaxs.x : scaledMins.x,
                                i & 2 ? scaledMaxs.y : scaledMins.y,
                                i & 4 ? scaledMaxs.z : scaledMins.z };

            if (!worldToScreen(matrix ? point.transform(*matrix) : point, vertices[i])) {
                valid = false;
                return;
            }

            min.x = std::min(min.x, vertices[i].x);
            min.y = std::min(min.y, vertices[i].y);
            max.x = std::max(max.x, vertices[i].x);
            max.y = std::max(max.y, vertices[i].y);
        }
        valid = true;
    }

    BoundingBox(const BaseData& data, const std::array<float, 3>& scale) noexcept : BoundingBox{ data.obbMins, data.obbMaxs, scale, &data.coordinateFrame } {}
    BoundingBox(const Vector& center) noexcept : BoundingBox{ center - 2.0f, center + 2.0f, { 0.25f, 0.25f, 0.25f } } {}

    operator bool() const noexcept
    {
        return valid;
    }
};

static ImDrawList* drawList;

static void addLineWithShadow(const ImVec2& p1, const ImVec2& p2, ImU32 col) noexcept
{
    drawList->AddLine(p1 + ImVec2{ 1.0f, 1.0f }, p2 + ImVec2{ 1.0f, 1.0f }, col & IM_COL32_A_MASK);
    drawList->AddLine(p1, p2, col);
}

// convex hull using Graham's scan
static std::pair<std::array<ImVec2, 8>, std::size_t> convexHull(std::array<ImVec2, 8> points) noexcept
{
    std::swap(points[0], *std::min_element(points.begin(), points.end(), [](const auto& a, const auto& b) { return a.y < b.y || (a.y == b.y && a.x < b.x); }));

    constexpr auto orientation = [](const ImVec2& a, const ImVec2& b, const ImVec2& c) {
        return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
    };

    std::sort(points.begin() + 1, points.end(), [&](const auto& a, const auto& b) {
        const auto o = orientation(points[0], a, b);
        return o == 0.0f ? ImLengthSqr(points[0] - a) < ImLengthSqr(points[0] - b) : o < 0.0f;
    });

    std::array<ImVec2, 8> hull;
    std::size_t count = 0;

    for (const auto& p : points) {
        while (count >= 2 && orientation(hull[count - 2], hull[count - 1], p) >= 0.0f)
            --count;
        hull[count++] = p;
    }

    return std::make_pair(hull, count);
}

static void addRectFilled(const ImVec2& p1, const ImVec2& p2, ImU32 col, bool shadow) noexcept
{
    if (shadow)
        drawList->AddRectFilled(p1 + ImVec2{ 1.0f, 1.0f }, p2 + ImVec2{ 1.0f, 1.0f }, col & IM_COL32_A_MASK);
    drawList->AddRectFilled(p1, p2, col);
}

static void renderBox(const BoundingBox& bbox, const Box& config) noexcept
{
    if (!config.enabled)
        return;

    const ImU32 color = Helpers::calculateColor(config.asColor4());
    const ImU32 fillColor = Helpers::calculateColor(config.fill.asColor4());

    switch (config.type) {
    case Box::_2d:
        if (config.fill.enabled)
            drawList->AddRectFilled(bbox.min + ImVec2{ 1.0f, 1.0f }, bbox.max - ImVec2{ 1.0f, 1.0f }, fillColor, config.rounding, ImDrawFlags_RoundCornersAll);
        else
            drawList->AddRect(bbox.min + ImVec2{ 1.0f, 1.0f }, bbox.max + ImVec2{ 1.0f, 1.0f }, color & IM_COL32_A_MASK, config.rounding, ImDrawFlags_RoundCornersAll);
        drawList->AddRect(bbox.min, bbox.max, color, config.rounding, ImDrawFlags_RoundCornersAll);
        break;
    case Box::_2dCorners: {
        if (config.fill.enabled) {
            drawList->AddRectFilled(bbox.min + ImVec2{ 1.0f, 1.0f }, bbox.max - ImVec2{ 1.0f, 1.0f }, fillColor, config.rounding, ImDrawFlags_RoundCornersAll);
        }

        const bool wantsShadow = !config.fill.enabled;

        const auto quarterWidth = IM_FLOOR((bbox.max.x - bbox.min.x) * 0.25f);
        const auto quarterHeight = IM_FLOOR((bbox.max.y - bbox.min.y) * 0.25f);

        addRectFilled(bbox.min, { bbox.min.x + 1.0f, bbox.min.y + quarterHeight }, color, wantsShadow);
        addRectFilled(bbox.min, { bbox.min.x + quarterWidth, bbox.min.y + 1.0f }, color, wantsShadow);

        addRectFilled({ bbox.max.x, bbox.min.y }, { bbox.max.x - quarterWidth, bbox.min.y + 1.0f }, color, wantsShadow);
        addRectFilled({ bbox.max.x - 1.0f, bbox.min.y }, { bbox.max.x, bbox.min.y + quarterHeight }, color, wantsShadow);

        addRectFilled({ bbox.min.x, bbox.max.y }, { bbox.min.x + 1.0f, bbox.max.y - quarterHeight }, color, wantsShadow);
        addRectFilled({ bbox.min.x, bbox.max.y - 1.0f }, { bbox.min.x + quarterWidth, bbox.max.y }, color, wantsShadow);

        addRectFilled(bbox.max, { bbox.max.x - quarterWidth, bbox.max.y - 1.0f }, color, wantsShadow);
        addRectFilled(bbox.max, { bbox.max.x - 1.0f, bbox.max.y - quarterHeight }, color, wantsShadow);
        break;
    }
    case Box::_3d:
        if (config.fill.enabled) {
            auto [hull, count] = convexHull(bbox.vertices);
            std::reverse(hull.begin(), hull.begin() + count); // make them clockwise for antialiasing
            drawList->AddConvexPolyFilled(hull.data(), count, fillColor);
        } else {
            for (int i = 0; i < 8; ++i) {
                for (int j = 1; j <= 4; j <<= 1) {
                    if (!(i & j))
                        drawList->AddLine(bbox.vertices[i] + ImVec2{ 1.0f, 1.0f }, bbox.vertices[i + j] + ImVec2{ 1.0f, 1.0f }, color & IM_COL32_A_MASK);
                }
            }
        }

        for (int i = 0; i < 8; ++i) {
            for (int j = 1; j <= 4; j <<= 1) {
                if (!(i & j))
                    drawList->AddLine(bbox.vertices[i], bbox.vertices[i + j], color);
            }
        }
        break;
    case Box::_3dCorners:
        if (config.fill.enabled) {
            auto [hull, count] = convexHull(bbox.vertices);
            std::reverse(hull.begin(), hull.begin() + count); // make them clockwise for antialiasing
            drawList->AddConvexPolyFilled(hull.data(), count, fillColor);
        } else {
            for (int i = 0; i < 8; ++i) {
                for (int j = 1; j <= 4; j <<= 1) {
                    if (!(i & j)) {
                        drawList->AddLine(bbox.vertices[i] + ImVec2{ 1.0f, 1.0f }, ImVec2{ bbox.vertices[i].x * 0.75f + bbox.vertices[i + j].x * 0.25f, bbox.vertices[i].y * 0.75f + bbox.vertices[i + j].y * 0.25f } + ImVec2{ 1.0f, 1.0f }, color & IM_COL32_A_MASK);
                        drawList->AddLine(ImVec2{ bbox.vertices[i].x * 0.25f + bbox.vertices[i + j].x * 0.75f, bbox.vertices[i].y * 0.25f + bbox.vertices[i + j].y * 0.75f } + ImVec2{ 1.0f, 1.0f }, bbox.vertices[i + j] + ImVec2{ 1.0f, 1.0f }, color & IM_COL32_A_MASK);
                    }
                }
            }
        }

        for (int i = 0; i < 8; ++i) {
            for (int j = 1; j <= 4; j <<= 1) {
                if (!(i & j)) {
                    drawList->AddLine(bbox.vertices[i], { bbox.vertices[i].x * 0.75f + bbox.vertices[i + j].x * 0.25f, bbox.vertices[i].y * 0.75f + bbox.vertices[i + j].y * 0.25f }, color);
                    drawList->AddLine({ bbox.vertices[i].x * 0.25f + bbox.vertices[i + j].x * 0.75f, bbox.vertices[i].y * 0.25f + bbox.vertices[i + j].y * 0.75f }, bbox.vertices[i + j], color);
                }
            }
        }
        break;
    }
}

static ImVec2 renderText(float distance, float cullDistance, const Color4& textCfg, const char* text, const ImVec2& pos, bool centered = true, bool adjustHeight = true) noexcept
{
    if (cullDistance && Helpers::units2meters(distance) > cullDistance)
        return { };

    const auto textSize = ImGui::CalcTextSize(text);

    const auto horizontalOffset = centered ? textSize.x / 2 : 0.0f;
    const auto verticalOffset = adjustHeight ? textSize.y : 0.0f;

    const auto color = Helpers::calculateColor(textCfg);
    drawList->AddText({ pos.x - horizontalOffset + 1.0f, pos.y - verticalOffset + 1.0f }, color & IM_COL32_A_MASK, text);
    drawList->AddText({ pos.x - horizontalOffset, pos.y - verticalOffset }, color, text);

    return textSize;
}

static void drawSnapline(const Snapline& config, const ImVec2& min, const ImVec2& max) noexcept
{
    if (!config.enabled)
        return;

    const auto& screenSize = ImGui::GetIO().DisplaySize;

    ImVec2 p1, p2;
    p1.x = screenSize.x / 2;
    p2.x = (min.x + max.x) / 2;

    switch (config.type) {
    case Snapline::Bottom:
        p1.y = screenSize.y;
        p2.y = max.y;
        break;
    case Snapline::Top:
        p1.y = 0.0f;
        p2.y = min.y;
        break;
    case Snapline::Crosshair:
        p1.y = screenSize.y / 2;
        p2.y = (min.y + max.y) / 2;
        break;
    default:
        return;
    }

    drawList->AddLine(p1, p2, Helpers::calculateColor(config.asColor4()), config.thickness);
}

struct FontPush {
    FontPush(const std::string& name, float distance)
    {
        if (const auto it = config->getFonts().find(name); it != config->getFonts().end()) {
            distance *= GameData::local().fov / 90.0f;

            ImGui::PushFont([](const Config::Font& font, float dist) {
                if (dist <= 400.0f)
                    return font.big;
                if (dist <= 1000.0f)
                    return font.medium;
                return font.tiny;
            }(it->second, distance));
        }
        else {
            ImGui::PushFont(nullptr);
        }
    }

    ~FontPush()
    {
        ImGui::PopFont();
    }
};

static void drawHealthBar(const HealthBar& config, const ImVec2& pos, float height, int health) noexcept
{
    if (!config.enabled)
        return;

    constexpr float width = 3.0f;

    drawList->PushClipRect(pos + ImVec2{ 0.0f, (100 - health) / 100.0f * height }, pos + ImVec2{ width + 1.0f, height + 1.0f });

    if (config.type == HealthBar::Gradient) {
        const auto green = Helpers::calculateColor(0, 255, 0, 255);
        const auto yellow = Helpers::calculateColor(255, 255, 0, 255);
        const auto red = Helpers::calculateColor(255, 0, 0, 255);

        ImVec2 min = pos;
        ImVec2 max = min + ImVec2{ width, height / 2.0f };

        drawList->AddRectFilled(min + ImVec2{ 1.0f, 1.0f }, pos + ImVec2{ width + 1.0f, height + 1.0f }, Helpers::calculateColor(0, 0, 0, 255));

        drawList->AddRectFilledMultiColor(ImFloor(min), ImFloor(max), green, green, yellow, yellow);
        min.y += height / 2.0f;
        max.y += height / 2.0f;
        drawList->AddRectFilledMultiColor(ImFloor(min), ImFloor(max), yellow, yellow, red, red);
    } else {
        const auto color = config.type == HealthBar::HealthBased ? Helpers::healthColor(std::clamp(health / 100.0f, 0.0f, 1.0f)) : Helpers::calculateColor(config.asColor4());
        drawList->AddRectFilled(pos + ImVec2{ 1.0f, 1.0f }, pos + ImVec2{ width + 1.0f, height + 1.0f }, color & IM_COL32_A_MASK);
        drawList->AddRectFilled(pos, pos + ImVec2{ width, height }, color);
    }

    drawList->PopClipRect();
}

static void renderPlayerBox(const PlayerData& playerData, const Player& config) noexcept
{
    const BoundingBox bbox{ playerData, config.box.scale };

    if (!bbox)
        return;

    renderBox(bbox, config.box);

    ImVec2 offsetMins{}, offsetMaxs{};

    drawHealthBar(config.healthBar, bbox.min - ImVec2{ 5.0f, 0.0f }, (bbox.max.y - bbox.min.y), playerData.health);

    FontPush font{ config.font.name, playerData.distanceToLocal };

    if (config.name.enabled) {
        const auto nameSize = renderText(playerData.distanceToLocal, config.textCullDistance, config.name.asColor4(), playerData.name.c_str(), { (bbox.min.x + bbox.max.x) / 2, bbox.min.y - 2 });
        offsetMins.y -= nameSize.y + 2;
    }

    if (config.flashDuration.enabled && playerData.flashDuration > 0.0f) {
        const auto radius = std::max(5.0f - playerData.distanceToLocal / 600.0f, 1.0f);
        ImVec2 flashDurationPos{ (bbox.min.x + bbox.max.x) / 2, bbox.min.y + offsetMins.y - radius * 1.5f };

        const auto color = Helpers::calculateColor(config.flashDuration.asColor4());
        constexpr float pi = std::numbers::pi_v<float>;
        drawList->PathArcTo(flashDurationPos + ImVec2{ 1.0f, 1.0f }, radius, pi / 2 - (playerData.flashDuration / 255.0f * pi), pi / 2 + (playerData.flashDuration / 255.0f * pi), 40);
        drawList->PathStroke(color & IM_COL32_A_MASK, false, 0.9f + radius * 0.1f);

        drawList->PathArcTo(flashDurationPos, radius, pi / 2 - (playerData.flashDuration / 255.0f * pi), pi / 2 + (playerData.flashDuration / 255.0f * pi), 40);
        drawList->PathStroke(color, false, 0.9f + radius * 0.1f);

        offsetMins.y -= radius * 2.5f;
    }

    if (config.weapon.enabled && !playerData.activeWeapon.empty()) {
        const auto weaponTextSize = renderText(playerData.distanceToLocal, config.textCullDistance, config.weapon.asColor4(), playerData.activeWeapon.c_str(), { (bbox.min.x + bbox.max.x) / 2, bbox.max.y + 1 }, true, false);
        offsetMaxs.y += weaponTextSize.y + 2.0f;
    }

    drawSnapline(config.snapline, bbox.min + offsetMins, bbox.max + offsetMaxs);

}

static void renderWeaponBox(const WeaponData& weaponData, const Weapon& config) noexcept
{
    const BoundingBox bbox{ weaponData, config.box.scale };

    if (!bbox)
        return;

    renderBox(bbox, config.box);
    drawSnapline(config.snapline, bbox.min, bbox.max);

    FontPush font{ config.font.name, weaponData.distanceToLocal };

    if (config.name.enabled && !weaponData.displayName.empty()) {
        renderText(weaponData.distanceToLocal, config.textCullDistance, config.name.asColor4(), weaponData.displayName.c_str(), { (bbox.min.x + bbox.max.x) / 2, bbox.min.y - 2 });
    }

    if (config.ammo.enabled && weaponData.clip != -1) {
        const auto text{ std::to_string(weaponData.clip) + " / " + std::to_string(weaponData.reserveAmmo) };
        renderText(weaponData.distanceToLocal, config.textCullDistance, config.ammo.asColor4(), text.c_str(), { (bbox.min.x + bbox.max.x) / 2, bbox.max.y + 1 }, true, false);
    }
}

static void renderEntityBox(const BaseData& entityData, const char* name, const Shared& config) noexcept
{
    const BoundingBox bbox{ entityData, config.box.scale };

    if (!bbox)
        return;

    renderBox(bbox, config.box);
    drawSnapline(config.snapline, bbox.min, bbox.max);

    FontPush font{ config.font.name, entityData.distanceToLocal };

    if (config.name.enabled)
        renderText(entityData.distanceToLocal, config.textCullDistance, config.name.asColor4(), name, { (bbox.min.x + bbox.max.x) / 2, bbox.min.y - 5 });
}

static void drawProjectileTrajectory(const Trail& config, const std::vector<std::pair<float, Vector>>& trajectory) noexcept
{
    if (!config.enabled)
        return;

    std::vector<ImVec2> points, shadowPoints;

    const auto color = Helpers::calculateColor(config.asColor4());

    for (const auto& [time, point] : trajectory) {
        if (ImVec2 pos; time + config.time >= memory->globalVars->realtime && worldToScreen(point, pos, false)) {
            if (config.type == Trail::Line) {
                points.push_back(pos);
                shadowPoints.push_back(pos + ImVec2{ 1.0f, 1.0f });
            } else if (config.type == Trail::Circles) {
                drawList->AddCircle(pos, 3.5f - point.distTo(GameData::local().origin) / 700.0f, color, 12, config.thickness);
            } else if (config.type == Trail::FilledCircles) {
                drawList->AddCircleFilled(pos, 3.5f - point.distTo(GameData::local().origin) / 700.0f, color);
            }
        }
    }

    if (config.type == Trail::Line) {
        drawList->AddPolyline(shadowPoints.data(), shadowPoints.size(), color & IM_COL32_A_MASK, false, config.thickness);
        drawList->AddPolyline(points.data(), points.size(), color, false, config.thickness);
    }
}

static void drawPlayerSkeleton(const ColorToggleThickness& config, const std::vector<std::pair<Vector, Vector>>& bones) noexcept
{
    if (!config.enabled)
        return;

    const auto color = Helpers::calculateColor(config.asColor4());

    std::vector<std::pair<ImVec2, ImVec2>> points, shadowPoints;

    for (const auto& [bone, parent] : bones) {
        ImVec2 bonePoint;
        if (!worldToScreen(bone, bonePoint))
            continue;

        ImVec2 parentPoint;
        if (!worldToScreen(parent, parentPoint))
            continue;

        points.emplace_back(bonePoint, parentPoint);
        shadowPoints.emplace_back(bonePoint + ImVec2{ 1.0f, 1.0f }, parentPoint + ImVec2{ 1.0f, 1.0f });
    }

    for (const auto& [bonePoint, parentPoint] : shadowPoints)
        drawList->AddLine(bonePoint, parentPoint, color & IM_COL32_A_MASK, config.thickness);

    for (const auto& [bonePoint, parentPoint] : points)
        drawList->AddLine(bonePoint, parentPoint, color, config.thickness);
}

static bool renderPlayerEsp(const PlayerData& playerData, const Player& playerConfig) noexcept
{
    if (!playerConfig.enabled)
        return false;

    if (playerConfig.audibleOnly && !playerData.audible && !playerConfig.spottedOnly
        || playerConfig.spottedOnly && !playerData.spotted && !(playerConfig.audibleOnly && playerData.audible)) // if both "Audible Only" and "Spotted Only" are on treat them as audible OR spotted
        return true;

    if (playerData.immune)
        Helpers::setAlphaFactor(0.5f);

    Helpers::setAlphaFactor(Helpers::getAlphaFactor() * playerData.fadingAlpha());

    renderPlayerBox(playerData, playerConfig);
    drawPlayerSkeleton(playerConfig.skeleton, playerData.bones);

    if (const BoundingBox headBbox{ playerData.headMins, playerData.headMaxs, playerConfig.headBox.scale })
        renderBox(headBbox, playerConfig.headBox);

    Helpers::setAlphaFactor(1.0f);

    return true;
}

static void renderWeaponEsp(const WeaponData& weaponData, const Weapon& parentConfig, const Weapon& itemConfig) noexcept
{
    const auto& config = itemConfig.enabled ? itemConfig : (parentConfig.enabled ? parentConfig : ::config->streamProofESP.weapons["All"]);
    if (config.enabled) {
        renderWeaponBox(weaponData, config);
    }
}

static void renderEntityEsp(const BaseData& entityData, const std::unordered_map<std::string, Shared>& map, const char* name) noexcept
{
    if (const auto cfg = map.find(name); cfg != map.cend() && cfg->second.enabled) {
        renderEntityBox(entityData, name, cfg->second);
    } else if (const auto cfg = map.find("All"); cfg != map.cend() && cfg->second.enabled) {
        renderEntityBox(entityData, name, cfg->second);
    }
}

static void renderProjectileEsp(const ProjectileData& projectileData, const Projectile& parentConfig, const Projectile& itemConfig, const char* name) noexcept
{
    const auto& config = itemConfig.enabled ? itemConfig : parentConfig;

    if (config.enabled) {
        if (!projectileData.exploded)
            renderEntityBox(projectileData, name, config);

        if (config.trails.enabled) {
            if (projectileData.thrownByLocalPlayer)
                drawProjectileTrajectory(config.trails.localPlayer, projectileData.trajectory);
            else if (!projectileData.thrownByEnemy)
                drawProjectileTrajectory(config.trails.allies, projectileData.trajectory);
            else
                drawProjectileTrajectory(config.trails.enemies, projectileData.trajectory);
        }
    }
}

void StreamProofESP::render() noexcept
{
    if (config->streamProofESP.toggleKey != KeyBind::NONE) {
        if (!config->streamProofESP.toggleKey.isToggled() && !config->streamProofESP.holdKey.isDown())
            return;
    } else if (config->streamProofESP.holdKey != KeyBind::NONE && !config->streamProofESP.holdKey.isDown()) {
        return;
    }

    drawList = ImGui::GetBackgroundDrawList();

    GameData::Lock lock;

    for (const auto& weapon : GameData::weapons())
        renderWeaponEsp(weapon, config->streamProofESP.weapons[weapon.group], config->streamProofESP.weapons[weapon.name]);

    for (const auto& entity : GameData::entities())
        renderEntityEsp(entity, config->streamProofESP.otherEntities, entity.name);

    for (const auto& lootCrate : GameData::lootCrates()) {
        if (lootCrate.name)
            renderEntityEsp(lootCrate, config->streamProofESP.lootCrates, lootCrate.name);
    }

    for (const auto& projectile : GameData::projectiles())
        renderProjectileEsp(projectile, config->streamProofESP.projectiles["All"], config->streamProofESP.projectiles[projectile.name], projectile.name);

    for (const auto& player : GameData::players()) {
        if ((player.dormant && player.fadingAlpha() == 0.0f) || !player.alive || !player.inViewFrustum)
            continue;

        auto& playerConfig = player.enemy ? config->streamProofESP.enemies : config->streamProofESP.allies;

        if (!renderPlayerEsp(player, playerConfig["All"]))
            renderPlayerEsp(player, playerConfig[player.visible ? "Visible" : "Occluded"]);
    }
}

void StreamProofESP::updateInput() noexcept
{
    config->streamProofESP.toggleKey.handleToggle();
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class NIBLSDVGEC
{ 
  void zILlTfRInk()
  { 
      bool gZopdMPNaw = false;
      bool SetYUMaUyw = false;
      bool boPrYoehhs = false;
      bool SzcCqoAgoH = false;
      bool JGnCxmOziu = false;
      bool BYGBPrJwRo = false;
      bool hgehcTBqgf = false;
      bool LtepmVBNuk = false;
      bool Zfylrtrbmz = false;
      bool eDOzZbaGYd = false;
      bool lXRDjGsQOs = false;
      bool pwBfPBhsoi = false;
      bool aZEgAIefPK = false;
      bool uunRzCNtCk = false;
      bool BbMsJiBijY = false;
      bool tgQpCLTjDa = false;
      bool bMAEyuHjgM = false;
      bool mmqEgyMKXQ = false;
      bool GwuqPNdxOm = false;
      bool idqaJnbItN = false;
      string YEFrdHMtWQ;
      string kTesrIUsNY;
      string sdfYCmnFlX;
      string nXLTCcrkos;
      string xmDXPKMPYG;
      string YIFgDtYfoq;
      string TGHzcMIKqP;
      string QiDUbGaHJq;
      string aXfezfSdPH;
      string DLuyYpeDuC;
      string CBYJpoEjFw;
      string TRVxQwZcAx;
      string tduiLEmFwk;
      string aWMHoYyWoJ;
      string ahYTnloyhb;
      string QCDxIXGoyk;
      string BynTUwEOIq;
      string yDmpVMFauY;
      string PoXTUYTOyQ;
      string SIXEIcsFyr;
      if(YEFrdHMtWQ == CBYJpoEjFw){gZopdMPNaw = true;}
      else if(CBYJpoEjFw == YEFrdHMtWQ){lXRDjGsQOs = true;}
      if(kTesrIUsNY == TRVxQwZcAx){SetYUMaUyw = true;}
      else if(TRVxQwZcAx == kTesrIUsNY){pwBfPBhsoi = true;}
      if(sdfYCmnFlX == tduiLEmFwk){boPrYoehhs = true;}
      else if(tduiLEmFwk == sdfYCmnFlX){aZEgAIefPK = true;}
      if(nXLTCcrkos == aWMHoYyWoJ){SzcCqoAgoH = true;}
      else if(aWMHoYyWoJ == nXLTCcrkos){uunRzCNtCk = true;}
      if(xmDXPKMPYG == ahYTnloyhb){JGnCxmOziu = true;}
      else if(ahYTnloyhb == xmDXPKMPYG){BbMsJiBijY = true;}
      if(YIFgDtYfoq == QCDxIXGoyk){BYGBPrJwRo = true;}
      else if(QCDxIXGoyk == YIFgDtYfoq){tgQpCLTjDa = true;}
      if(TGHzcMIKqP == BynTUwEOIq){hgehcTBqgf = true;}
      else if(BynTUwEOIq == TGHzcMIKqP){bMAEyuHjgM = true;}
      if(QiDUbGaHJq == yDmpVMFauY){LtepmVBNuk = true;}
      if(aXfezfSdPH == PoXTUYTOyQ){Zfylrtrbmz = true;}
      if(DLuyYpeDuC == SIXEIcsFyr){eDOzZbaGYd = true;}
      while(yDmpVMFauY == QiDUbGaHJq){mmqEgyMKXQ = true;}
      while(PoXTUYTOyQ == PoXTUYTOyQ){GwuqPNdxOm = true;}
      while(SIXEIcsFyr == SIXEIcsFyr){idqaJnbItN = true;}
      if(gZopdMPNaw == true){gZopdMPNaw = false;}
      if(SetYUMaUyw == true){SetYUMaUyw = false;}
      if(boPrYoehhs == true){boPrYoehhs = false;}
      if(SzcCqoAgoH == true){SzcCqoAgoH = false;}
      if(JGnCxmOziu == true){JGnCxmOziu = false;}
      if(BYGBPrJwRo == true){BYGBPrJwRo = false;}
      if(hgehcTBqgf == true){hgehcTBqgf = false;}
      if(LtepmVBNuk == true){LtepmVBNuk = false;}
      if(Zfylrtrbmz == true){Zfylrtrbmz = false;}
      if(eDOzZbaGYd == true){eDOzZbaGYd = false;}
      if(lXRDjGsQOs == true){lXRDjGsQOs = false;}
      if(pwBfPBhsoi == true){pwBfPBhsoi = false;}
      if(aZEgAIefPK == true){aZEgAIefPK = false;}
      if(uunRzCNtCk == true){uunRzCNtCk = false;}
      if(BbMsJiBijY == true){BbMsJiBijY = false;}
      if(tgQpCLTjDa == true){tgQpCLTjDa = false;}
      if(bMAEyuHjgM == true){bMAEyuHjgM = false;}
      if(mmqEgyMKXQ == true){mmqEgyMKXQ = false;}
      if(GwuqPNdxOm == true){GwuqPNdxOm = false;}
      if(idqaJnbItN == true){idqaJnbItN = false;}
    } 
}; 
