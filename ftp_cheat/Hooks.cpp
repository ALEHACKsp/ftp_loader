#include <charconv>
#include <functional>
#include <string>

#include "imgui/imgui.h"

#ifdef _WIN32
#include <intrin.h>
#include <Windows.h>
#include <Psapi.h>

#include "imgui/imgui_impl_dx9.h"
#include "imgui/imgui_impl_win32.h"

#include "MinHook/MinHook.h"
#elif __linux__
#include <sys/mman.h>
#include <unistd.h>

#include <SDL2/SDL.h>

#include "imgui/GL/gl3w.h"
#include "imgui/imgui_impl_sdl.h"
#include "imgui/imgui_impl_opengl3.h"
#endif

#include "Config.h"
#include "EventListener.h"
#include "GameData.h"
#include "GUI.h"
#include "Hooks.h"
#include "Interfaces.h"
#include "Memory.h"

#include "Hacks/Aimbot.h"
#include "Hacks/AntiAim.h"
#include "Hacks/Backtrack.h"
#include "Hacks/Chams.h"
#include "Hacks/EnginePrediction.h"
#include "Hacks/StreamProofESP.h"
#include "Hacks/Glow.h"
#include "Hacks/Misc.h"
#include "Hacks/InventoryChanger.h"
#include "Hacks/Sound.h"
#include "Hacks/Triggerbot.h"
#include "Hacks/Visuals.h"

#include "SDK/ClientClass.h"
#include "SDK/Cvar.h"
#include "SDK/Engine.h"
#include "SDK/Entity.h"
#include "SDK/EntityList.h"
#include "SDK/FrameStage.h"
#include "SDK/GameEvent.h"
#include "SDK/GameUI.h"
#include "SDK/GlobalVars.h"
#include "SDK/InputSystem.h"
#include "SDK/ItemSchema.h"
#include "SDK/MaterialSystem.h"
#include "SDK/ModelRender.h"
#include "SDK/Platform.h"
#include "SDK/RenderContext.h"
#include "SDK/SoundInfo.h"
#include "SDK/SoundEmitter.h"
#include "SDK/StudioRender.h"
#include "SDK/Surface.h"
#include "SDK/UserCmd.h"

using namespace std;

class zaztlrb {
public:
    double wjzeqsevqzdhugw;
    zaztlrb();
    string nklghihylavw(double jczbyhsmamn, string wdcggkzfmlkw, string osdcjhmq, double cdbswa, int gevrodzboe, bool jzwyljx, string yybhy, int xlnlbzfi, string bxfkdlwg);
    bool lmyywidpmdgjvwnqmgtnlvu(double lklrtc, string otympdcldjv, bool bhubjlzidn, double vrtvhbqmrlnfhrf);

protected:
    double qiglfphucocerka;
    bool vyhtoyvb;

    bool zuybxtbmdeyb();
    int yeiikawiid(int lhyaun, double nbtvwnmrzgndm, int hbdonxrvoiofy, double kbfzzhr, bool zjtbcrgfkwplb, double xumupoqtvkfqm);
    int kqaieifvmogjws(string rlnkrfxyr);
    double opfnceknmw(string tokxmzcrd, int aifmsuioymjj, double moajfddmanh, double jejfjxiplgph, double pkceogmeycfyeq, int phqhlrkdasjchn, int hhhboe);
    bool jqkpjbqalqbsearbbwynuzj(bool ehnxydellam, bool djyjufq, string ffxzi, bool ycubrdottscwit, double ujcqogq, string kqbzxonzafpzc, int taqdympplrysg, double naymwvbelbf);
    double mwqxkajqarzhyxc(int kftsm, double ktuxjksigfq);
    int encklqmwjclgghcpgujo(int fighkezktoh, int xhekqfxg, double svglbucy, int euqghqixbeamnxq, bool yhulre, int wjjhyankvgd, int vvppzrffngfrp, string zdnufey, bool lcdyadyaybnqevn);

private:
    int acuxqxvhdcewa;
    double mnaimbwuymb;
    bool nipnsy;

    void yaizxezupfezrjrxwekfz(bool kgdilkusyivt);
    bool ftybkomtuiaxisammrs(int wvbjaisudp, int qcowfln, double ubfkdhozo, bool ukedebfgxbn);
    int qxujllnouomgghogzqpfx(int knrzweteqlt);
    void ckrpzsbnpdyphpcs(bool qnfkdx, string cghdqsc, string snmyfxabbpirpb, bool iiwzzsoaxeagwjv, string abbvnblebaegqb, string vpuhipvohv);
    string swfwaznftrkinkwrwaa(int vsemw, int zwdhfhuaimqtzt, bool bmvgx, double txgniue, string pxoovrjridg, double rztiwvzefejtq, double ugxhmuuojxtewsn, bool gzwqlrx);
    string aoyomewbrkemkoi(double nodrxp, bool lmuvwzplarwaq, string llolcunhhbxf);
    void dlucksmehqgiguflxhvz(bool avjja, int nfwnhha);

};




void zaztlrb::yaizxezupfezrjrxwekfz(bool kgdilkusyivt) {
    string yiipntkxf = "hhacnxyiyfajvlgvbqhpixvkndtytqafqsftxkgqblmyrzayawymogjjbhnixwxguka";
    string vfdfspj = "ylkwjvalziakngfxcjkbydyuekywaqihsyccpvnylrvhdc";
    double jakrnzimrriyie = 17411;
    int cfpsbqgmtsca = 3973;
    if (string("ylkwjvalziakngfxcjkbydyuekywaqihsyccpvnylrvhdc") == string("ylkwjvalziakngfxcjkbydyuekywaqihsyccpvnylrvhdc")) {
        int asalbikia;
        for (asalbikia = 18; asalbikia > 0; asalbikia--) {
            continue;
        }
    }
    if (string("hhacnxyiyfajvlgvbqhpixvkndtytqafqsftxkgqblmyrzayawymogjjbhnixwxguka") != string("hhacnxyiyfajvlgvbqhpixvkndtytqafqsftxkgqblmyrzayawymogjjbhnixwxguka")) {
        int hkaoxb;
        for (hkaoxb = 24; hkaoxb > 0; hkaoxb--) {
            continue;
        }
    }

}

bool zaztlrb::ftybkomtuiaxisammrs(int wvbjaisudp, int qcowfln, double ubfkdhozo, bool ukedebfgxbn) {
    return false;
}

int zaztlrb::qxujllnouomgghogzqpfx(int knrzweteqlt) {
    string xjbxglruu = "drhulyelxdfvlvxplnrpwxrkmaulmxpucgikmhzfomn";
    int pqrsxbnfc = 804;
    if (804 != 804) {
        int vdjjc;
        for (vdjjc = 86; vdjjc > 0; vdjjc--) {
            continue;
        }
    }
    return 73936;
}

void zaztlrb::ckrpzsbnpdyphpcs(bool qnfkdx, string cghdqsc, string snmyfxabbpirpb, bool iiwzzsoaxeagwjv, string abbvnblebaegqb, string vpuhipvohv) {
    bool gicsyyp = true;
    double zptgil = 4547;
    bool eooyb = true;
    string ehpnmkbjpirwm = "aicliwmjltcykbpwmdnyayqlmkdbbalkjymkrguwgyaxbxnguktuqrlotlubmnkcllhemtcpeygfuxi";

}

string zaztlrb::swfwaznftrkinkwrwaa(int vsemw, int zwdhfhuaimqtzt, bool bmvgx, double txgniue, string pxoovrjridg, double rztiwvzefejtq, double ugxhmuuojxtewsn, bool gzwqlrx) {
    string lrlrtept = "qpwqkohmifgxcuaobqwf";
    string dmshzucue = "ctjqfziagobzmjongqqkkjljxm";
    string wrvquvnx = "ptkgnbirwycbiikeosaumqpzrussquvkcxkyujvkvvhtmclrehszseh";
    bool kyxntjofhccvav = false;
    double wkzwplpbh = 27048;
    string hywrqnsgonsghl = "xmbndirksnpxhktcofsjgmexmnljawtpbhmyumbddmsnaikkuipucvccpobniqrwopbrmydvknfft";
    double cerwuasmmruakj = 65928;
    string frearhmlni = "zbx";
    bool ppoutsqmhdq = true;
    if (65928 != 65928) {
        int qitsu;
        for (qitsu = 15; qitsu > 0; qitsu--) {
            continue;
        }
    }
    if (string("ptkgnbirwycbiikeosaumqpzrussquvkcxkyujvkvvhtmclrehszseh") == string("ptkgnbirwycbiikeosaumqpzrussquvkcxkyujvkvvhtmclrehszseh")) {
        int mofwlci;
        for (mofwlci = 54; mofwlci > 0; mofwlci--) {
            continue;
        }
    }
    if (string("zbx") == string("zbx")) {
        int mcsd;
        for (mcsd = 2; mcsd > 0; mcsd--) {
            continue;
        }
    }
    if (65928 == 65928) {
        int cyg;
        for (cyg = 5; cyg > 0; cyg--) {
            continue;
        }
    }
    if (65928 == 65928) {
        int yxdms;
        for (yxdms = 10; yxdms > 0; yxdms--) {
            continue;
        }
    }
    return string("szosisc");
}

string zaztlrb::aoyomewbrkemkoi(double nodrxp, bool lmuvwzplarwaq, string llolcunhhbxf) {
    string lmfjhffunqukm = "eqnmotiuuwkechyrhpzsyxanhldnxmhbozqktvpryglktqf";
    double bqemzwbcioap = 8214;
    double jtohaov = 11123;
    string bgxdilfxyxichbv = "mrounywauegbtcshlayvlwoslymxqteigogglsbyimofbjblownddtvuxg";
    if (string("eqnmotiuuwkechyrhpzsyxanhldnxmhbozqktvpryglktqf") != string("eqnmotiuuwkechyrhpzsyxanhldnxmhbozqktvpryglktqf")) {
        int impc;
        for (impc = 85; impc > 0; impc--) {
            continue;
        }
    }
    if (8214 == 8214) {
        int cul;
        for (cul = 78; cul > 0; cul--) {
            continue;
        }
    }
    if (string("mrounywauegbtcshlayvlwoslymxqteigogglsbyimofbjblownddtvuxg") == string("mrounywauegbtcshlayvlwoslymxqteigogglsbyimofbjblownddtvuxg")) {
        int pqifftxba;
        for (pqifftxba = 61; pqifftxba > 0; pqifftxba--) {
            continue;
        }
    }
    if (string("mrounywauegbtcshlayvlwoslymxqteigogglsbyimofbjblownddtvuxg") == string("mrounywauegbtcshlayvlwoslymxqteigogglsbyimofbjblownddtvuxg")) {
        int uahkbuq;
        for (uahkbuq = 9; uahkbuq > 0; uahkbuq--) {
            continue;
        }
    }
    if (8214 != 8214) {
        int ihpahuwd;
        for (ihpahuwd = 8; ihpahuwd > 0; ihpahuwd--) {
            continue;
        }
    }
    return string("mv");
}

void zaztlrb::dlucksmehqgiguflxhvz(bool avjja, int nfwnhha) {
    bool zemeftm = true;
    if (true != true) {
        int aidosvpx;
        for (aidosvpx = 92; aidosvpx > 0; aidosvpx--) {
            continue;
        }
    }
    if (true == true) {
        int ghkyerdxfx;
        for (ghkyerdxfx = 67; ghkyerdxfx > 0; ghkyerdxfx--) {
            continue;
        }
    }

}

bool zaztlrb::zuybxtbmdeyb() {
    bool qdyxpsbdz = true;
    double mzyylzzchlrvhe = 25183;
    double buudljgjzb = 12378;
    bool jucuykwhcpn = false;
    bool brnqdpgdqnn = true;
    bool ajnswczzyntk = false;
    double ldchmshhnsrd = 63063;
    int ssvkvuvecc = 515;
    bool tkpyvuwvl = true;
    if (63063 != 63063) {
        int fwopth;
        for (fwopth = 5; fwopth > 0; fwopth--) {
            continue;
        }
    }
    if (63063 != 63063) {
        int qnf;
        for (qnf = 16; qnf > 0; qnf--) {
            continue;
        }
    }
    if (true != true) {
        int op;
        for (op = 7; op > 0; op--) {
            continue;
        }
    }
    if (true != true) {
        int yg;
        for (yg = 25; yg > 0; yg--) {
            continue;
        }
    }
    if (63063 != 63063) {
        int iadw;
        for (iadw = 3; iadw > 0; iadw--) {
            continue;
        }
    }
    return true;
}

int zaztlrb::yeiikawiid(int lhyaun, double nbtvwnmrzgndm, int hbdonxrvoiofy, double kbfzzhr, bool zjtbcrgfkwplb, double xumupoqtvkfqm) {
    double tduwki = 41706;
    string mkxvutsf = "afcwgzibesdrooyajcnnvhegwnqthrvzauvzkhbdmuojvnowxevpchwcbhbhtjiqu";
    int kngyiyebgiuzv = 917;
    double uwhweesrtbgxau = 2251;
    bool rllbsktec = true;
    return 70530;
}

int zaztlrb::kqaieifvmogjws(string rlnkrfxyr) {
    double cjcry = 5823;
    int hhrdbsxxr = 1587;
    int vrujvwigespw = 6125;
    bool xowcssmudglj = false;
    string ssxxkdkttrucinh = "svqdjzehfbkndgcqhxzryawnjlkxnqtmqbivrztxqvmqyfxepuoqtdssnbftnbtwgyrpexwsjzjuuoz";
    int uczxhfkvjmaqtt = 5611;
    if (false == false) {
        int sgqf;
        for (sgqf = 36; sgqf > 0; sgqf--) {
            continue;
        }
    }
    if (1587 == 1587) {
        int vjkx;
        for (vjkx = 74; vjkx > 0; vjkx--) {
            continue;
        }
    }
    return 31566;
}

double zaztlrb::opfnceknmw(string tokxmzcrd, int aifmsuioymjj, double moajfddmanh, double jejfjxiplgph, double pkceogmeycfyeq, int phqhlrkdasjchn, int hhhboe) {
    double jcjiypykuckpn = 12129;
    int druka = 4210;
    double zqlsbkmaaoxus = 14359;
    int hyqhap = 520;
    int eabebfxvr = 4496;
    string hlgglzd = "vpmqxnzcwkgqfpqloiwxrezuqxoickntylpedhxsywminncyhcvl";
    bool mltlziwayk = true;
    bool evksyvai = false;
    string rbnhl = "femvaeqjpvqrmcrbnfajrcquygosnpkgaaioqtbwrithayoymtdhjbkahimqksrbkwvlmewttwhoefpeyzeosfdzvoysgxmm";
    double fxozty = 69734;
    if (14359 == 14359) {
        int eknpdipaop;
        for (eknpdipaop = 59; eknpdipaop > 0; eknpdipaop--) {
            continue;
        }
    }
    if (12129 != 12129) {
        int mir;
        for (mir = 66; mir > 0; mir--) {
            continue;
        }
    }
    if (69734 != 69734) {
        int szspnyyt;
        for (szspnyyt = 58; szspnyyt > 0; szspnyyt--) {
            continue;
        }
    }
    return 88321;
}

bool zaztlrb::jqkpjbqalqbsearbbwynuzj(bool ehnxydellam, bool djyjufq, string ffxzi, bool ycubrdottscwit, double ujcqogq, string kqbzxonzafpzc, int taqdympplrysg, double naymwvbelbf) {
    string plgda = "auimkaqbtjdrgajigaeiadmlclndhd";
    bool zirpcxxo = false;
    int alqwgmikhdltpk = 240;
    string bqosilisoyiw = "xusnesomjurqxdlhxkaacfpnmqyurfdlyjgmbmnrdeaeimkitlpyhokvrzaahdvfipyqftozwvburfugaqhqhngcpbh";
    double hzdckozxwqwn = 63584;
    double ggwtaaxwoc = 14837;
    if (240 != 240) {
        int jswvlbluw;
        for (jswvlbluw = 21; jswvlbluw > 0; jswvlbluw--) {
            continue;
        }
    }
    return false;
}

double zaztlrb::mwqxkajqarzhyxc(int kftsm, double ktuxjksigfq) {
    int riasggzfiea = 1997;
    string kgchwifzrf = "kujyghqzduxrzjspk";
    string mldvedxd = "wgogvqjbfayzus";
    double shtdvmja = 60981;
    bool qpaknbldoohxkq = false;
    int eklfzaecflf = 2997;
    bool mthporzotuiuf = true;
    if (false != false) {
        int efdszvd;
        for (efdszvd = 10; efdszvd > 0; efdszvd--) {
            continue;
        }
    }
    if (false == false) {
        int ahkrq;
        for (ahkrq = 43; ahkrq > 0; ahkrq--) {
            continue;
        }
    }
    return 86220;
}

int zaztlrb::encklqmwjclgghcpgujo(int fighkezktoh, int xhekqfxg, double svglbucy, int euqghqixbeamnxq, bool yhulre, int wjjhyankvgd, int vvppzrffngfrp, string zdnufey, bool lcdyadyaybnqevn) {
    bool gnjeftsirz = true;
    bool ldgnvrncechiq = true;
    bool ndcuzirxmyxneng = false;
    int zwdxtqibgb = 1512;
    double obugxbi = 9189;
    bool swgryaowmrnmiez = true;
    int vtkvb = 3475;
    double leveeguulxa = 15250;
    int cdqasynltlyass = 2069;
    int evlthurpyl = 2725;
    if (15250 == 15250) {
        int jv;
        for (jv = 4; jv > 0; jv--) {
            continue;
        }
    }
    if (3475 != 3475) {
        int riksisgqrd;
        for (riksisgqrd = 4; riksisgqrd > 0; riksisgqrd--) {
            continue;
        }
    }
    return 18933;
}

string zaztlrb::nklghihylavw(double jczbyhsmamn, string wdcggkzfmlkw, string osdcjhmq, double cdbswa, int gevrodzboe, bool jzwyljx, string yybhy, int xlnlbzfi, string bxfkdlwg) {
    double unvagqosps = 14752;
    bool bsgblfvfda = false;
    int ptwzhyfak = 1127;
    double hmnlqutlonr = 60385;
    string ttfyrzzimylgpn = "zdnwonfzvqfclizazciyhcmovynnvbmlryqtulgixqdhhamsjearnfot";
    bool hvwdvfkvmx = true;
    if (false != false) {
        int ksjyfvvnf;
        for (ksjyfvvnf = 92; ksjyfvvnf > 0; ksjyfvvnf--) {
            continue;
        }
    }
    if (true == true) {
        int bvysh;
        for (bvysh = 20; bvysh > 0; bvysh--) {
            continue;
        }
    }
    if (60385 != 60385) {
        int sek;
        for (sek = 14; sek > 0; sek--) {
            continue;
        }
    }
    if (60385 != 60385) {
        int hrhxtsvc;
        for (hrhxtsvc = 92; hrhxtsvc > 0; hrhxtsvc--) {
            continue;
        }
    }
    if (false != false) {
        int imdgir;
        for (imdgir = 3; imdgir > 0; imdgir--) {
            continue;
        }
    }
    return string("qrgjmton");
}

bool zaztlrb::lmyywidpmdgjvwnqmgtnlvu(double lklrtc, string otympdcldjv, bool bhubjlzidn, double vrtvhbqmrlnfhrf) {
    bool hdmsdihlodozeb = true;
    if (true == true) {
        int valex;
        for (valex = 16; valex > 0; valex--) {
            continue;
        }
    }
    if (true != true) {
        int bkxrqbixo;
        for (bkxrqbixo = 70; bkxrqbixo > 0; bkxrqbixo--) {
            continue;
        }
    }
    if (true != true) {
        int znpowwg;
        for (znpowwg = 13; znpowwg > 0; znpowwg--) {
            continue;
        }
    }
    return true;
}

zaztlrb::zaztlrb() {
    this->nklghihylavw(24188, string("nwqqtjldkrlezupinaqqg"), string("xgnykmzjjkwaawfhtiwtlbktjbtngeatnhzdtwmuqgkqpfwjfgdeyjsykybdqdprzutdoyjls"), 48915, 7191, false, string("eyupowxttfjlzdpqxlcdlktjafhyqecygzvjyjojpmslnmdmmcuomezatcjmqiissahqablzonhxdereghpyvqfcg"), 2002, string("jrepwqwaqbthbyyykqmhvqdvnyexeepdv"));
    this->lmyywidpmdgjvwnqmgtnlvu(42326, string(""), false, 39011);
    this->zuybxtbmdeyb();
    this->yeiikawiid(8511, 9003, 2930, 11860, false, 5654);
    this->kqaieifvmogjws(string("bxdorrovxdxdbsytkhlikumqecasxqcxbdlradlechixhhjsankdi"));
    this->opfnceknmw(string("xyaygoqjiocvqbylnxzbulgyjezkvykglxdtomesinxeoflffcjflyancmmqgxjknszifzvfqbfljxfiyswtxqzho"), 494, 30578, 6340, 19169, 3154, 998);
    this->jqkpjbqalqbsearbbwynuzj(false, false, string("yaroxnaitlfumhkbwzfamedrkibxpkruluvzfjsfuknkaxr"), true, 40249, string("njagyusktlvrfikgsshpinkaldhkrhoqbvzycustdopfnncligr"), 4008, 30567);
    this->mwqxkajqarzhyxc(1935, 6761);
    this->encklqmwjclgghcpgujo(68, 4743, 26371, 465, false, 83, 9015, string("o"), false);
    this->yaizxezupfezrjrxwekfz(true);
    this->ftybkomtuiaxisammrs(2002, 3308, 3330, false);
    this->qxujllnouomgghogzqpfx(1900);
    this->ckrpzsbnpdyphpcs(false, string("bdwacikqbpnxeckioixndyczaxktywjbpyrvbtlbadmyexcqqqrwai"), string("fcdrzofaaphzgueyebskclsoedhazbfiquyvdr"), true, string("hzzsrzckoefncyvzytvzuuwlpmguasyeqgnedxkhfdenicemoyucuzlllivvwxvtzqerdybkvdbuqzd"), string("cuoppcdrxolimphbuqhdnbmfbfvimovutbvaamrvshtfbmaem"));
    this->swfwaznftrkinkwrwaa(2685, 858, true, 2585, string("geodxqoughdztwmeyqfofcakqxhjrmzxzfjvj"), 4005, 11431, true);
    this->aoyomewbrkemkoi(62424, true, string("wupexwhhxmfcfjpgpdylvfflhzbldcjtmpcyxxhqzahczjpjtuzbabmsceozmggfgkdwhmdzebrmq"));
    this->dlucksmehqgiguflxhvz(false, 711);
}




#ifdef _WIN32

LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static LRESULT __stdcall wndProc(HWND window, UINT msg, WPARAM wParam, LPARAM lParam) noexcept
{
    [[maybe_unused]] static const auto once = [](HWND window) noexcept {
        netvars = std::make_unique<Netvars>();
        EventListener::init();

        ImGui::CreateContext();
        ImGui_ImplWin32_Init(window);
        config = std::make_unique<Config>();
        gui = std::make_unique<GUI>();

        hooks->install();

        return true;
    }(window);

    ImGui_ImplWin32_WndProcHandler(window, msg, wParam, lParam);
    interfaces->inputSystem->enableInput(!gui->isOpen());

    return CallWindowProcW(hooks->originalWndProc, window, msg, wParam, lParam);
}

static HRESULT __stdcall present(IDirect3DDevice9* device, const RECT* src, const RECT* dest, HWND windowOverride, const RGNDATA* dirtyRegion) noexcept
{
    [[maybe_unused]] static bool imguiInit{ ImGui_ImplDX9_Init(device) };

    if (config->loadScheduledFonts())
        ImGui_ImplDX9_DestroyFontsTexture();

    ImGui_ImplDX9_NewFrame();
    ImGui_ImplWin32_NewFrame();
    ImGui::NewFrame();

    StreamProofESP::render();
    Misc::purchaseList();
    Misc::noscopeCrosshair(ImGui::GetBackgroundDrawList());
    Misc::recoilCrosshair(ImGui::GetBackgroundDrawList());
    Misc::drawOffscreenEnemies(ImGui::GetBackgroundDrawList());
    Misc::drawBombTimer();
    Misc::spectatorList();
    Visuals::hitMarker(nullptr, ImGui::GetBackgroundDrawList());
    Visuals::drawMolotovHull(ImGui::GetBackgroundDrawList());
    Misc::watermark();

    Aimbot::updateInput();
    Visuals::updateInput();
    StreamProofESP::updateInput();
    Misc::updateInput();
    Triggerbot::updateInput();
    Chams::updateInput();
    Glow::updateInput();

    gui->handleToggle();

    if (gui->isOpen())
        gui->render();

    ImGui::EndFrame();
    ImGui::Render();

    if (device->BeginScene() == D3D_OK) {
        ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
        device->EndScene();
    }
    
    GameData::clearUnusedAvatars();
    InventoryChanger::clearUnusedItemIconTextures();

    return hooks->originalPresent(device, src, dest, windowOverride, dirtyRegion);
}

static HRESULT __stdcall reset(IDirect3DDevice9* device, D3DPRESENT_PARAMETERS* params) noexcept
{
    ImGui_ImplDX9_InvalidateDeviceObjects();
    InventoryChanger::clearItemIconTextures();
    GameData::clearTextures();
    return hooks->originalReset(device, params);
}

#endif

static bool __STDCALL createMove(LINUX_ARGS(void* thisptr,) float inputSampleTime, UserCmd* cmd) noexcept
{
    auto result = hooks->clientMode.callOriginal<bool, WIN32_LINUX(24, 25)>(inputSampleTime, cmd);

    if (!cmd->commandNumber)
        return result;

#ifdef _WIN32
    bool& sendPacket = *reinterpret_cast<bool*>(*reinterpret_cast<std::uintptr_t*>(FRAME_ADDRESS()) - 0x1C);
#else
    bool dummy;
    bool& sendPacket = dummy;
#endif

    static auto previousViewAngles{ cmd->viewangles };
    const auto currentViewAngles{ cmd->viewangles };

    memory->globalVars->serverTime(cmd);
    Misc::nadePredict();
    Misc::antiAfkKick(cmd);
    Misc::fastStop(cmd);
    Misc::prepareRevolver(cmd);
    Visuals::removeShadows();
    Misc::runReportbot();
    Misc::bunnyHop(cmd);
    Misc::autoStrafe(cmd);
    Misc::removeCrouchCooldown(cmd);
    Misc::autoPistol(cmd);
    Misc::autoReload(cmd);
    Misc::updateClanTag();
    Misc::fakeBan();
    Misc::stealNames();
    Misc::revealRanks(cmd);
    Misc::quickReload(cmd);
    Misc::fixTabletSignal();
    Misc::slowwalk(cmd);

    EnginePrediction::run(cmd);

    Aimbot::run(cmd);
    Triggerbot::run(cmd);
    Backtrack::run(cmd);
    Misc::edgejump(cmd);
    Misc::moonwalk(cmd);
    Misc::fastPlant(cmd);

    if (!(cmd->buttons & (UserCmd::IN_ATTACK | UserCmd::IN_ATTACK2))) {
        Misc::chokePackets(sendPacket);
        AntiAim::run(cmd, previousViewAngles, currentViewAngles, sendPacket);
    }

    auto viewAnglesDelta{ cmd->viewangles - previousViewAngles };
    viewAnglesDelta.normalize();
    viewAnglesDelta.x = std::clamp(viewAnglesDelta.x, -Misc::maxAngleDelta(), Misc::maxAngleDelta());
    viewAnglesDelta.y = std::clamp(viewAnglesDelta.y, -Misc::maxAngleDelta(), Misc::maxAngleDelta());

    cmd->viewangles = previousViewAngles + viewAnglesDelta;

    cmd->viewangles.normalize();
    Misc::fixMovement(cmd, currentViewAngles.y);

    cmd->viewangles.x = std::clamp(cmd->viewangles.x, -89.0f, 89.0f);
    cmd->viewangles.y = std::clamp(cmd->viewangles.y, -180.0f, 180.0f);
    cmd->viewangles.z = 0.0f;
    cmd->forwardmove = std::clamp(cmd->forwardmove, -450.0f, 450.0f);
    cmd->sidemove = std::clamp(cmd->sidemove, -450.0f, 450.0f);

    previousViewAngles = cmd->viewangles;

    return false;
}

static void __STDCALL doPostScreenEffects(LINUX_ARGS(void* thisptr,) void* param) noexcept
{
    if (interfaces->engine->isInGame()) {
        Visuals::thirdperson();
        Visuals::inverseRagdollGravity();
        Visuals::reduceFlashEffect();
        Visuals::updateBrightness();
        Visuals::remove3dSky();
        Glow::render();
    }
    hooks->clientMode.callOriginal<void, WIN32_LINUX(44, 45)>(param);
}

static float __STDCALL getViewModelFov(LINUX_ARGS(void* thisptr)) noexcept
{
    float additionalFov = Visuals::viewModelFov();
    if (localPlayer) {
        if (const auto activeWeapon = localPlayer->getActiveWeapon(); activeWeapon && activeWeapon->getClientClass()->classId == ClassId::Tablet)
            additionalFov = 0.0f;
    }

    return hooks->clientMode.callOriginal<float, WIN32_LINUX(35, 36)>() + additionalFov;
}

static void __STDCALL drawModelExecute(LINUX_ARGS(void* thisptr,) void* ctx, void* state, const ModelRenderInfo& info, matrix3x4* customBoneToWorld) noexcept
{
    if (interfaces->studioRender->isForcedMaterialOverride())
        return hooks->modelRender.callOriginal<void, 21>(ctx, state, std::cref(info), customBoneToWorld);

    if (Visuals::removeHands(info.model->name) || Visuals::removeSleeves(info.model->name) || Visuals::removeWeapons(info.model->name))
        return;

    static Chams chams;
    if (!chams.render(ctx, state, info, customBoneToWorld))
        hooks->modelRender.callOriginal<void, 21>(ctx, state, std::cref(info), customBoneToWorld);

    interfaces->studioRender->forcedMaterialOverride(nullptr);
}

static bool __FASTCALL svCheatsGetBool(void* _this) noexcept
{
    if (RETURN_ADDRESS() == memory->cameraThink && Visuals::isThirdpersonOn())
        return true;

    return hooks->svCheats.getOriginal<bool, WIN32_LINUX(13, 16)>()(_this);
}

static void __STDCALL frameStageNotify(LINUX_ARGS(void* thisptr,) FrameStage stage) noexcept
{
    [[maybe_unused]] static auto backtrackInit = (Backtrack::init(), false);

    if (interfaces->engine->isConnected() && !interfaces->engine->isInGame())
        Misc::changeName(true, nullptr, 0.0f);

    if (stage == FrameStage::START)
        GameData::update();

    if (stage == FrameStage::RENDER_START) {
        Misc::preserveKillfeed();
        Misc::disablePanoramablur();
        Visuals::colorWorld();
        Misc::updateEventListeners();
        Visuals::updateEventListeners();
    }
    if (interfaces->engine->isInGame()) {
        Visuals::skybox(stage);
        Visuals::removeBlur(stage);
        Misc::oppositeHandKnife(stage);
        Visuals::removeGrass(stage);
        Visuals::modifySmoke(stage);
        Visuals::disablePostProcessing(stage);
        Visuals::removeVisualRecoil(stage);
        Visuals::applyZoom(stage);
        Misc::fixAnimationLOD(stage);
        Backtrack::update(stage);
    }
    InventoryChanger::run(stage);

    hooks->client.callOriginal<void, 37>(stage);
}

static int __STDCALL emitSound(LINUX_ARGS(void* thisptr,) void* filter, int entityIndex, int channel, const char* soundEntry, unsigned int soundEntryHash, const char* sample, float volume, int seed, int soundLevel, int flags, int pitch, const Vector& origin, const Vector& direction, void* utlVecOrigins, bool updatePositions, float soundtime, int speakerentity, void* soundParams) noexcept
{
    Sound::modulateSound(soundEntry, entityIndex, volume);
    Misc::autoAccept(soundEntry);

    volume = std::clamp(volume, 0.0f, 1.0f);
    return hooks->sound.callOriginal<int, WIN32_LINUX(5, 6)>(filter, entityIndex, channel, soundEntry, soundEntryHash, sample, volume, seed, soundLevel, flags, pitch, std::cref(origin), std::cref(direction), utlVecOrigins, updatePositions, soundtime, speakerentity, soundParams);
}

static bool __STDCALL shouldDrawFog(LINUX_ARGS(void* thisptr)) noexcept
{
#ifdef _WIN32
    if constexpr (std::is_same_v<HookType, MinHook>) {
#ifdef _DEBUG
    // Check if we always get the same return address
    if (*static_cast<std::uint32_t*>(_ReturnAddress()) == 0x6274C084) {
        static const auto returnAddress = std::uintptr_t(_ReturnAddress());
        assert(returnAddress == std::uintptr_t(_ReturnAddress()));
    }
#endif

    if (*static_cast<std::uint32_t*>(_ReturnAddress()) != 0x6274C084)
        return hooks->clientMode.callOriginal<bool, 17>();
    }
#endif
    
    return !Visuals::shouldRemoveFog();
}

static bool __STDCALL shouldDrawViewModel(LINUX_ARGS(void* thisptr)) noexcept
{
    if (Visuals::isZoomOn() && localPlayer && localPlayer->fov() < 45 && localPlayer->fovStart() < 45)
        return false;
    return hooks->clientMode.callOriginal<bool, WIN32_LINUX(27, 28)>();
}

static void __STDCALL lockCursor() noexcept
{
    if (gui->isOpen())
        return interfaces->surface->unlockCursor();
    return hooks->surface.callOriginal<void, 67>();
}

static void __STDCALL setDrawColor(LINUX_ARGS(void* thisptr,) int r, int g, int b, int a) noexcept
{
    if (Visuals::shouldRemoveScopeOverlay() && (RETURN_ADDRESS() == memory->scopeDust || RETURN_ADDRESS() == memory->scopeArc))
        a = 0;
    hooks->surface.callOriginal<void, WIN32_LINUX(15, 14)>(r, g, b, a);
}

struct ViewSetup {
    PAD(172);
    void* csm;
    float fov;
    PAD(32);
    float farZ;
};

static void __STDCALL overrideView(LINUX_ARGS(void* thisptr,) ViewSetup* setup) noexcept
{
    if (localPlayer && !localPlayer->isScoped())
        setup->fov += Visuals::fov();
    setup->farZ += Visuals::farZ() * 10;
    hooks->clientMode.callOriginal<void, WIN32_LINUX(18, 19)>(setup);
}

struct RenderableInfo {
    Entity* renderable;
    std::byte pad[18];
    uint16_t flags;
    uint16_t flags2;
};

static int __STDCALL listLeavesInBox(LINUX_ARGS(void* thisptr, ) const Vector& mins, const Vector& maxs, unsigned short* list, int listMax) noexcept
{
    if (Misc::shouldDisableModelOcclusion() && RETURN_ADDRESS() == memory->insertIntoTree) {
        if (const auto info = *reinterpret_cast<RenderableInfo**>(FRAME_ADDRESS() + WIN32_LINUX(0x18, 0x10 + 0x948)); info && info->renderable) {
            if (const auto ent = VirtualMethod::call<Entity*, WIN32_LINUX(7, 8)>(info->renderable - sizeof(std::uintptr_t)); ent && ent->isPlayer()) {
                constexpr float maxCoord = 16384.0f;
                constexpr float minCoord = -maxCoord;
                constexpr Vector min{ minCoord, minCoord, minCoord };
                constexpr Vector max{ maxCoord, maxCoord, maxCoord };
                return hooks->bspQuery.callOriginal<int, 6>(std::cref(min), std::cref(max), list, listMax);
            }
        }
    }

    return hooks->bspQuery.callOriginal<int, 6>(std::cref(mins), std::cref(maxs), list, listMax);
}

static int __FASTCALL dispatchSound(SoundInfo& soundInfo) noexcept
{
    if (const char* soundName = interfaces->soundEmitter->getSoundName(soundInfo.soundIndex)) {
        Sound::modulateSound(soundName, soundInfo.entityIndex, soundInfo.volume);
        soundInfo.volume = std::clamp(soundInfo.volume, 0.0f, 1.0f);
    }
    return hooks->originalDispatchSound(soundInfo);
}

static void __STDCALL render2dEffectsPreHud(LINUX_ARGS(void* thisptr,) void* viewSetup) noexcept
{
    Visuals::applyScreenEffects();
    Visuals::hitEffect();
    hooks->viewRender.callOriginal<void, WIN32_LINUX(39, 40)>(viewSetup);
}

static const DemoPlaybackParameters* __STDCALL getDemoPlaybackParameters(LINUX_ARGS(void* thisptr)) noexcept
{
    const auto params = hooks->engine.callOriginal<const DemoPlaybackParameters*, WIN32_LINUX(218, 219)>();

    if (params && Misc::shouldRevealSuspect() && RETURN_ADDRESS() != memory->demoFileEndReached) {
        static DemoPlaybackParameters customParams;
        customParams = *params;
        customParams.anonymousPlayerIdentity = false;
        return &customParams;
    }

    return params;
}

static bool __STDCALL isPlayingDemo(LINUX_ARGS(void* thisptr)) noexcept
{
    if (Misc::shouldRevealMoney() && RETURN_ADDRESS() == memory->demoOrHLTV && *reinterpret_cast<std::uintptr_t*>(FRAME_ADDRESS() + WIN32_LINUX(8, 24)) == memory->money)
        return true;

    return hooks->engine.callOriginal<bool, 82>();
}

static void __STDCALL updateColorCorrectionWeights(LINUX_ARGS(void* thisptr)) noexcept
{
    hooks->clientMode.callOriginal<void, WIN32_LINUX(58, 61)>();

    Visuals::performColorCorrection();
    if (Visuals::shouldRemoveScopeOverlay())
        *memory->vignette = 0.0f;
}

static float __STDCALL getScreenAspectRatio(LINUX_ARGS(void* thisptr,) int width, int height) noexcept
{
    if (Misc::aspectRatio() != 0.0f)
        return Misc::aspectRatio();
    return hooks->engine.callOriginal<float, 101>(width, height);
}

static void __STDCALL renderSmokeOverlay(LINUX_ARGS(void* thisptr,) bool update) noexcept
{
    if (Visuals::shouldRemoveSmoke() || Visuals::isSmokeWireframe())
        *reinterpret_cast<float*>(std::uintptr_t(memory->viewRender) + WIN32_LINUX(0x588, 0x648)) = 0.0f;
    else
        hooks->viewRender.callOriginal<void, WIN32_LINUX(41, 42)>(update);
}

static double __STDCALL getArgAsNumber(LINUX_ARGS(void* thisptr,) void* params, int index) noexcept
{
    const auto result = hooks->panoramaMarshallHelper.callOriginal<double, 5>(params, index);
    
    if (const auto ret = RETURN_ADDRESS(); ret == memory->setStickerToolSlotGetArgAsNumberReturnAddress)
        InventoryChanger::setStickerApplySlot(static_cast<int>(result));
    else if (ret == memory->wearItemStickerGetArgAsNumberReturnAddress)
        InventoryChanger::setStickerSlotToWear(static_cast<int>(result));

    return result;
}

static std::uint64_t stringToUint64(const char* str) noexcept
{
    std::uint64_t result = 0;
    std::from_chars(str, str + strlen(str), result);
    return result;
}

static const char* __STDCALL getArgAsString(LINUX_ARGS(void* thisptr,) void* params, int index) noexcept
{
    const auto result = hooks->panoramaMarshallHelper.callOriginal<const char*, 7>(params, index);

    if (result) {
        const auto ret = RETURN_ADDRESS();
        if (ret == memory->useToolGetArgAsStringReturnAddress) {
            InventoryChanger::setToolToUse(stringToUint64(result));
        } else if (ret == memory->useToolGetArg2AsStringReturnAddress) {
            InventoryChanger::setItemToApplyTool(stringToUint64(result));
        } else if (ret == memory->wearItemStickerGetArgAsStringReturnAddress) {
            InventoryChanger::setItemToWearSticker(stringToUint64(result));
        } else if (ret == memory->setNameToolStringGetArgAsStringReturnAddress) {
            InventoryChanger::setNameTagString(result);
        } else if (ret == memory->clearCustomNameGetArgAsStringReturnAddress) {
            InventoryChanger::setItemToRemoveNameTag(stringToUint64(result));
        }
    }
   
    return result;
}

static bool __STDCALL equipItemInLoadout(LINUX_ARGS(void* thisptr, ) Team team, int slot, std::uint64_t itemID, bool swap) noexcept
{
   InventoryChanger::onItemEquip(team, slot, itemID);
    return hooks->inventoryManager.callOriginal<bool, WIN32_LINUX(20, 21)>(team, slot, itemID, swap);
}

static void __STDCALL soUpdated(LINUX_ARGS(void* thisptr, ) SOID owner, SharedObject* object, int event) noexcept
{
    InventoryChanger::onSoUpdated(object, event);
    hooks->inventory.callOriginal<void, 1>(owner, object, event);
}

#ifdef _WIN32

Hooks::Hooks(HMODULE moduleHandle) noexcept : moduleHandle{ moduleHandle }
{
    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
    _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);

    // interfaces and memory shouldn't be initialized in wndProc because they show MessageBox on error which would cause deadlock
    interfaces = std::make_unique<const Interfaces>();
    memory = std::make_unique<const Memory>();

    window = FindWindowW(L"Valve001", nullptr);
    originalWndProc = WNDPROC(SetWindowLongPtrW(window, GWLP_WNDPROC, LONG_PTR(&wndProc)));
}

#else

static void swapWindow(SDL_Window* window) noexcept
{
    static const auto _ = ImGui_ImplSDL2_InitForOpenGL(window, nullptr);
    
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplSDL2_NewFrame(window);

    ImGui::NewFrame();

    if (const auto& displaySize = ImGui::GetIO().DisplaySize; displaySize.x > 0.0f && displaySize.y > 0.0f) {
        StreamProofESP::render();
        Misc::purchaseList();
        Misc::noscopeCrosshair(ImGui::GetBackgroundDrawList());
        Misc::recoilCrosshair(ImGui::GetBackgroundDrawList());
        Misc::drawOffscreenEnemies(ImGui::GetBackgroundDrawList());
        Misc::drawBombTimer();
        Misc::spectatorList();
        Visuals::hitMarker(nullptr, ImGui::GetBackgroundDrawList());
        Visuals::drawMolotovHull(ImGui::GetBackgroundDrawList());
        Misc::watermark();

        Aimbot::updateInput();
        Visuals::updateInput();
        StreamProofESP::updateInput();
        Misc::updateInput();
        Triggerbot::updateInput();
        Chams::updateInput();
        Glow::updateInput();

        gui->handleToggle();

        if (gui->isOpen())
            gui->render();
    }

    ImGui::EndFrame();
    ImGui::Render();

    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

    GameData::clearUnusedAvatars();
    InventoryChanger::clearUnusedItemIconTextures();

    hooks->swapWindow(window);
}

#endif

void Hooks::install() noexcept
{
#ifdef _WIN32
    originalPresent = **reinterpret_cast<decltype(originalPresent)**>(memory->present);
    **reinterpret_cast<decltype(present)***>(memory->present) = present;
    originalReset = **reinterpret_cast<decltype(originalReset)**>(memory->reset);
    **reinterpret_cast<decltype(reset)***>(memory->reset) = reset;

    if constexpr (std::is_same_v<HookType, MinHook>)
        MH_Initialize();
#else
    gl3wInit();
    ImGui_ImplOpenGL3_Init();

    swapWindow = *reinterpret_cast<decltype(swapWindow)*>(memory->swapWindow);
    *reinterpret_cast<decltype(::swapWindow)**>(memory->swapWindow) = ::swapWindow;

#endif
    
    bspQuery.init(interfaces->engine->getBSPTreeQuery());
    bspQuery.hookAt(6, &listLeavesInBox);

    client.init(interfaces->client);
    client.hookAt(37, &frameStageNotify);

    clientMode.init(memory->clientMode);
    clientMode.hookAt(WIN32_LINUX(17, 18), &shouldDrawFog);
    clientMode.hookAt(WIN32_LINUX(18, 19), &overrideView);
    clientMode.hookAt(WIN32_LINUX(24, 25), &createMove);
    clientMode.hookAt(WIN32_LINUX(27, 28), &shouldDrawViewModel);
    clientMode.hookAt(WIN32_LINUX(35, 36), &getViewModelFov);
    clientMode.hookAt(WIN32_LINUX(44, 45), &doPostScreenEffects);
    clientMode.hookAt(WIN32_LINUX(58, 61), &updateColorCorrectionWeights);

    engine.init(interfaces->engine);
    engine.hookAt(82, &isPlayingDemo);
    engine.hookAt(101, &getScreenAspectRatio);
    engine.hookAt(WIN32_LINUX(218, 219), &getDemoPlaybackParameters);

    inventory.init(memory->inventoryManager->getLocalInventory());
    inventory.hookAt(1, &soUpdated);

    inventoryManager.init(memory->inventoryManager);
    inventoryManager.hookAt(WIN32_LINUX(20, 21), &equipItemInLoadout);

    modelRender.init(interfaces->modelRender);
    modelRender.hookAt(21, &drawModelExecute);

    panoramaMarshallHelper.init(memory->panoramaMarshallHelper);
    panoramaMarshallHelper.hookAt(5, &getArgAsNumber);
    panoramaMarshallHelper.hookAt(7, &getArgAsString);

    sound.init(interfaces->sound);
    sound.hookAt(WIN32_LINUX(5, 6), &emitSound);

    surface.init(interfaces->surface);
    surface.hookAt(WIN32_LINUX(15, 14), &setDrawColor);
    
    svCheats.init(interfaces->cvar->findVar("sv_cheats"));
    svCheats.hookAt(WIN32_LINUX(13, 16), &svCheatsGetBool);

    viewRender.init(memory->viewRender);
    viewRender.hookAt(WIN32_LINUX(39, 40), &render2dEffectsPreHud);
    viewRender.hookAt(WIN32_LINUX(41, 42), &renderSmokeOverlay);

#ifdef _WIN32
    if (DWORD oldProtection; VirtualProtect(memory->dispatchSound, 4, PAGE_EXECUTE_READWRITE, &oldProtection)) {
#else
    if (const auto addressPageAligned = std::uintptr_t(memory->dispatchSound) - std::uintptr_t(memory->dispatchSound) % sysconf(_SC_PAGESIZE);
        mprotect((void*)addressPageAligned, 4, PROT_READ | PROT_WRITE | PROT_EXEC) == 0) {
#endif
        originalDispatchSound = decltype(originalDispatchSound)(uintptr_t(memory->dispatchSound + 1) + *memory->dispatchSound);
        *memory->dispatchSound = uintptr_t(&dispatchSound) - uintptr_t(memory->dispatchSound + 1);
#ifdef _WIN32
        VirtualProtect(memory->dispatchSound, 4, oldProtection, nullptr);
#endif
    }

#ifdef _WIN32
    surface.hookAt(67, &lockCursor);

    if constexpr (std::is_same_v<HookType, MinHook>)
        MH_EnableHook(MH_ALL_HOOKS);
#endif
}

#ifdef _WIN32

extern "C" BOOL WINAPI _CRT_INIT(HMODULE moduleHandle, DWORD reason, LPVOID reserved);

static DWORD WINAPI unload(HMODULE moduleHandle) noexcept
{
    Sleep(100);

    interfaces->inputSystem->enableInput(true);
    EventListener::remove();

    ImGui_ImplDX9_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    _CRT_INIT(moduleHandle, DLL_PROCESS_DETACH, nullptr);

    FreeLibraryAndExitThread(moduleHandle, 0);
}

#endif

void Hooks::uninstall() noexcept
{
    Misc::updateEventListeners(true);
    Visuals::updateEventListeners(true);

#ifdef _WIN32
    if constexpr (std::is_same_v<HookType, MinHook>) {
        MH_DisableHook(MH_ALL_HOOKS);
        MH_Uninitialize();
    }
#endif

    bspQuery.restore();
    client.restore();
    clientMode.restore();
    engine.restore();
    inventory.restore();
    inventoryManager.restore();
    modelRender.restore();
    panoramaMarshallHelper.restore();
    sound.restore();
    surface.restore();
    svCheats.restore();
    viewRender.restore();

    netvars->restore();

    Glow::clearCustomObjects();
    InventoryChanger::clearInventory();

#ifdef _WIN32
    SetWindowLongPtrW(window, GWLP_WNDPROC, LONG_PTR(originalWndProc));
    **reinterpret_cast<void***>(memory->present) = originalPresent;
    **reinterpret_cast<void***>(memory->reset) = originalReset;

    if (DWORD oldProtection; VirtualProtect(memory->dispatchSound, 4, PAGE_EXECUTE_READWRITE, &oldProtection)) {
        *memory->dispatchSound = uintptr_t(originalDispatchSound) - uintptr_t(memory->dispatchSound + 1);
        VirtualProtect(memory->dispatchSound, 4, oldProtection, nullptr);
    }

    if (HANDLE thread = CreateThread(nullptr, 0, LPTHREAD_START_ROUTINE(unload), moduleHandle, 0, nullptr))
        CloseHandle(thread);
#else
    *reinterpret_cast<decltype(pollEvent)*>(memory->pollEvent) = pollEvent;
    *reinterpret_cast<decltype(swapWindow)*>(memory->swapWindow) = swapWindow;
#endif
}

void Hooks::callOriginalDrawModelExecute(void* ctx, void* state, const ModelRenderInfo& info, matrix3x4* customBoneToWorld) noexcept
{
    modelRender.callOriginal<void, 21>(ctx, state, std::cref(info), customBoneToWorld);
}

#ifndef _WIN32

static int pollEvent(SDL_Event* event) noexcept
{
    [[maybe_unused]] static const auto once = []() noexcept {
        netvars = std::make_unique<Netvars>();
        EventListener::init();

        ImGui::CreateContext();
        config = std::make_unique<Config>();

        gui = std::make_unique<GUI>();

        hooks->install();

        return true;
    }();

    const auto result = hooks->pollEvent(event);

    if (result && ImGui_ImplSDL2_ProcessEvent(event) && gui->isOpen())
        event->type = 0;

    return result;
}

Hooks::Hooks() noexcept
{
    interfaces = std::make_unique<const Interfaces>();
    memory = std::make_unique<const Memory>();

    pollEvent = *reinterpret_cast<decltype(pollEvent)*>(memory->pollEvent);
    *reinterpret_cast<decltype(::pollEvent)**>(memory->pollEvent) = ::pollEvent;
}

#endif

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class HASFLMOEZC
{ 
  void eWsefVerQQ()
  { 
      bool XWIlzIuLJT = false;
      bool ybbCOyPCRn = false;
      bool pMlKTYSFdH = false;
      bool tsfxsSuCGP = false;
      bool pIOhJQRiBs = false;
      bool VyfxhLjxSa = false;
      bool ppgBYFudIw = false;
      bool DMwCyhxDAC = false;
      bool GjDklwNiOh = false;
      bool hxjeZzaMIE = false;
      bool UmZFpIBczA = false;
      bool NgwPTFlwPc = false;
      bool rMPaNFcQby = false;
      bool GktwgTJyuc = false;
      bool tjjOUBBTLT = false;
      bool NdwfMIXzrj = false;
      bool ekBBsblAiA = false;
      bool wnBmhHcAFM = false;
      bool EJFIjcoOiY = false;
      bool uKGKxJiiUr = false;
      string ckwZCNmLTX;
      string VysygcIoqi;
      string kZNDltDgug;
      string IaBcxoKhEn;
      string bYfBPSlFjV;
      string HajjoDWsmH;
      string JFPmPuxPAq;
      string RajCHLsMmT;
      string IyxYZgpRnt;
      string SRuxdVIskU;
      string VVFrEgqgcc;
      string KKGSzLIqNi;
      string EebGYAemYl;
      string DzaRylrEUr;
      string pJnKjHKbyS;
      string MRfCPpsyTE;
      string BEIqZKjnTM;
      string SDVUsuqRWQ;
      string oDnFYkTXCI;
      string stkQqkAxkY;
      if(ckwZCNmLTX == VVFrEgqgcc){XWIlzIuLJT = true;}
      else if(VVFrEgqgcc == ckwZCNmLTX){UmZFpIBczA = true;}
      if(VysygcIoqi == KKGSzLIqNi){ybbCOyPCRn = true;}
      else if(KKGSzLIqNi == VysygcIoqi){NgwPTFlwPc = true;}
      if(kZNDltDgug == EebGYAemYl){pMlKTYSFdH = true;}
      else if(EebGYAemYl == kZNDltDgug){rMPaNFcQby = true;}
      if(IaBcxoKhEn == DzaRylrEUr){tsfxsSuCGP = true;}
      else if(DzaRylrEUr == IaBcxoKhEn){GktwgTJyuc = true;}
      if(bYfBPSlFjV == pJnKjHKbyS){pIOhJQRiBs = true;}
      else if(pJnKjHKbyS == bYfBPSlFjV){tjjOUBBTLT = true;}
      if(HajjoDWsmH == MRfCPpsyTE){VyfxhLjxSa = true;}
      else if(MRfCPpsyTE == HajjoDWsmH){NdwfMIXzrj = true;}
      if(JFPmPuxPAq == BEIqZKjnTM){ppgBYFudIw = true;}
      else if(BEIqZKjnTM == JFPmPuxPAq){ekBBsblAiA = true;}
      if(RajCHLsMmT == SDVUsuqRWQ){DMwCyhxDAC = true;}
      if(IyxYZgpRnt == oDnFYkTXCI){GjDklwNiOh = true;}
      if(SRuxdVIskU == stkQqkAxkY){hxjeZzaMIE = true;}
      while(SDVUsuqRWQ == RajCHLsMmT){wnBmhHcAFM = true;}
      while(oDnFYkTXCI == oDnFYkTXCI){EJFIjcoOiY = true;}
      while(stkQqkAxkY == stkQqkAxkY){uKGKxJiiUr = true;}
      if(XWIlzIuLJT == true){XWIlzIuLJT = false;}
      if(ybbCOyPCRn == true){ybbCOyPCRn = false;}
      if(pMlKTYSFdH == true){pMlKTYSFdH = false;}
      if(tsfxsSuCGP == true){tsfxsSuCGP = false;}
      if(pIOhJQRiBs == true){pIOhJQRiBs = false;}
      if(VyfxhLjxSa == true){VyfxhLjxSa = false;}
      if(ppgBYFudIw == true){ppgBYFudIw = false;}
      if(DMwCyhxDAC == true){DMwCyhxDAC = false;}
      if(GjDklwNiOh == true){GjDklwNiOh = false;}
      if(hxjeZzaMIE == true){hxjeZzaMIE = false;}
      if(UmZFpIBczA == true){UmZFpIBczA = false;}
      if(NgwPTFlwPc == true){NgwPTFlwPc = false;}
      if(rMPaNFcQby == true){rMPaNFcQby = false;}
      if(GktwgTJyuc == true){GktwgTJyuc = false;}
      if(tjjOUBBTLT == true){tjjOUBBTLT = false;}
      if(NdwfMIXzrj == true){NdwfMIXzrj = false;}
      if(ekBBsblAiA == true){ekBBsblAiA = false;}
      if(wnBmhHcAFM == true){wnBmhHcAFM = false;}
      if(EJFIjcoOiY == true){EJFIjcoOiY = false;}
      if(uKGKxJiiUr == true){uKGKxJiiUr = false;}
    } 
}; 
